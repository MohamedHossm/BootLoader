
BootApplicationSent.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000130  08008000  08008000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000011e0  08008130  08008130  00008130  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000000a8  08009310  08009310  00009310  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080093b8  080093b8  00010014  2**0
                  CONTENTS
  4 .ARM          00000000  080093b8  080093b8  00010014  2**0
                  CONTENTS
  5 .preinit_array 00000000  080093b8  080093b8  00010014  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080093b8  080093b8  000093b8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  080093bc  080093bc  000093bc  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000014  20000000  080093c0  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000140  20000014  080093d4  00010014  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  20000154  080093d4  00010154  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  00010014  2**0
                  CONTENTS, READONLY
 12 .comment      00000043  00000000  00000000  0001003d  2**0
                  CONTENTS, READONLY
 13 .debug_info   000039f3  00000000  00000000  00010080  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00000f33  00000000  00000000  00013a73  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 000004c0  00000000  00000000  000149a8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 0000035d  00000000  00000000  00014e68  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00000817  00000000  00000000  000151c5  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0000235e  00000000  00000000  000159dc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    00005dc2  00000000  00000000  00017d3a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_frame  00001118  00000000  00000000  0001dafc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 0000005d  00000000  00000000  0001ec14  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08008130 <__do_global_dtors_aux>:
 8008130:	b510      	push	{r4, lr}
 8008132:	4c05      	ldr	r4, [pc, #20]	; (8008148 <__do_global_dtors_aux+0x18>)
 8008134:	7823      	ldrb	r3, [r4, #0]
 8008136:	b933      	cbnz	r3, 8008146 <__do_global_dtors_aux+0x16>
 8008138:	4b04      	ldr	r3, [pc, #16]	; (800814c <__do_global_dtors_aux+0x1c>)
 800813a:	b113      	cbz	r3, 8008142 <__do_global_dtors_aux+0x12>
 800813c:	4804      	ldr	r0, [pc, #16]	; (8008150 <__do_global_dtors_aux+0x20>)
 800813e:	f3af 8000 	nop.w
 8008142:	2301      	movs	r3, #1
 8008144:	7023      	strb	r3, [r4, #0]
 8008146:	bd10      	pop	{r4, pc}
 8008148:	20000014 	.word	0x20000014
 800814c:	00000000 	.word	0x00000000
 8008150:	080092f8 	.word	0x080092f8

08008154 <frame_dummy>:
 8008154:	b508      	push	{r3, lr}
 8008156:	4b03      	ldr	r3, [pc, #12]	; (8008164 <frame_dummy+0x10>)
 8008158:	b11b      	cbz	r3, 8008162 <frame_dummy+0xe>
 800815a:	4903      	ldr	r1, [pc, #12]	; (8008168 <frame_dummy+0x14>)
 800815c:	4803      	ldr	r0, [pc, #12]	; (800816c <frame_dummy+0x18>)
 800815e:	f3af 8000 	nop.w
 8008162:	bd08      	pop	{r3, pc}
 8008164:	00000000 	.word	0x00000000
 8008168:	20000018 	.word	0x20000018
 800816c:	080092f8 	.word	0x080092f8

08008170 <EXTI_u8Setter_IRQ>:
#include"EXTI_Conf.h"
#include"EXTI_Interface.h"

static void (*EXTI_PtrCallBack[EXTI_TOTAL])(void) = {NULLPTR };

Error_t EXTI_u8Setter_IRQ(EXTI_Line_t copy_u8Line, void (*CopyFun)(void)) {
 8008170:	b480      	push	{r7}
 8008172:	b085      	sub	sp, #20
 8008174:	af00      	add	r7, sp, #0
 8008176:	4603      	mov	r3, r0
 8008178:	6039      	str	r1, [r7, #0]
 800817a:	71fb      	strb	r3, [r7, #7]
	Error_t local_u8Status = OK;
 800817c:	2300      	movs	r3, #0
 800817e:	73fb      	strb	r3, [r7, #15]
	if (*CopyFun != NULLPTR) {
 8008180:	683b      	ldr	r3, [r7, #0]
 8008182:	2b00      	cmp	r3, #0
 8008184:	d00b      	beq.n	800819e <EXTI_u8Setter_IRQ+0x2e>
		if (copy_u8Line <= EXTI_Line15) {
 8008186:	79fb      	ldrb	r3, [r7, #7]
 8008188:	2b0f      	cmp	r3, #15
 800818a:	d805      	bhi.n	8008198 <EXTI_u8Setter_IRQ+0x28>
			EXTI_PtrCallBack[copy_u8Line] = CopyFun;
 800818c:	79fb      	ldrb	r3, [r7, #7]
 800818e:	4908      	ldr	r1, [pc, #32]	; (80081b0 <EXTI_u8Setter_IRQ+0x40>)
 8008190:	683a      	ldr	r2, [r7, #0]
 8008192:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 8008196:	e004      	b.n	80081a2 <EXTI_u8Setter_IRQ+0x32>
		} else {
			local_u8Status = NOK;
 8008198:	2301      	movs	r3, #1
 800819a:	73fb      	strb	r3, [r7, #15]
 800819c:	e001      	b.n	80081a2 <EXTI_u8Setter_IRQ+0x32>
		}
	} else {
		local_u8Status = NOK;
 800819e:	2301      	movs	r3, #1
 80081a0:	73fb      	strb	r3, [r7, #15]
	}
	return local_u8Status;
 80081a2:	7bfb      	ldrb	r3, [r7, #15]
}
 80081a4:	4618      	mov	r0, r3
 80081a6:	3714      	adds	r7, #20
 80081a8:	46bd      	mov	sp, r7
 80081aa:	bc80      	pop	{r7}
 80081ac:	4770      	bx	lr
 80081ae:	bf00      	nop
 80081b0:	20000030 	.word	0x20000030

080081b4 <EXTI_u8En>:
	 */
	// do nothing
	return OK;
}

Error_t EXTI_u8En(EXTI_Line_t copy_u8Line) {
 80081b4:	b480      	push	{r7}
 80081b6:	b085      	sub	sp, #20
 80081b8:	af00      	add	r7, sp, #0
 80081ba:	4603      	mov	r3, r0
 80081bc:	71fb      	strb	r3, [r7, #7]
	Error_t Copy_u8State = OK;
 80081be:	2300      	movs	r3, #0
 80081c0:	73fb      	strb	r3, [r7, #15]
	if (copy_u8Line < EXTI_TOTAL) {
 80081c2:	79fb      	ldrb	r3, [r7, #7]
 80081c4:	2b0f      	cmp	r3, #15
 80081c6:	d80a      	bhi.n	80081de <EXTI_u8En+0x2a>
		SET_BIT(EXTI->EXTI_IMR, copy_u8Line);
 80081c8:	4b09      	ldr	r3, [pc, #36]	; (80081f0 <EXTI_u8En+0x3c>)
 80081ca:	681b      	ldr	r3, [r3, #0]
 80081cc:	79fa      	ldrb	r2, [r7, #7]
 80081ce:	2101      	movs	r1, #1
 80081d0:	fa01 f202 	lsl.w	r2, r1, r2
 80081d4:	4611      	mov	r1, r2
 80081d6:	4a06      	ldr	r2, [pc, #24]	; (80081f0 <EXTI_u8En+0x3c>)
 80081d8:	430b      	orrs	r3, r1
 80081da:	6013      	str	r3, [r2, #0]
 80081dc:	e001      	b.n	80081e2 <EXTI_u8En+0x2e>
	} else {
		Copy_u8State = NOK;
 80081de:	2301      	movs	r3, #1
 80081e0:	73fb      	strb	r3, [r7, #15]
	}
	return Copy_u8State;
 80081e2:	7bfb      	ldrb	r3, [r7, #15]
}
 80081e4:	4618      	mov	r0, r3
 80081e6:	3714      	adds	r7, #20
 80081e8:	46bd      	mov	sp, r7
 80081ea:	bc80      	pop	{r7}
 80081ec:	4770      	bx	lr
 80081ee:	bf00      	nop
 80081f0:	40010400 	.word	0x40010400

080081f4 <EXTI_u8CLR_pend>:
	} else {
		Copy_u8State = NOK;
	}
	return Copy_u8State;
}
Error_t EXTI_u8CLR_pend(EXTI_Line_t copy_u8Line) {
 80081f4:	b480      	push	{r7}
 80081f6:	b085      	sub	sp, #20
 80081f8:	af00      	add	r7, sp, #0
 80081fa:	4603      	mov	r3, r0
 80081fc:	71fb      	strb	r3, [r7, #7]
	Error_t Copy_u8State = OK;
 80081fe:	2300      	movs	r3, #0
 8008200:	73fb      	strb	r3, [r7, #15]
	if (copy_u8Line < EXTI_TOTAL) {
 8008202:	79fb      	ldrb	r3, [r7, #7]
 8008204:	2b0f      	cmp	r3, #15
 8008206:	d80a      	bhi.n	800821e <EXTI_u8CLR_pend+0x2a>
		SET_BIT(EXTI->EXTI_PR, copy_u8Line);
 8008208:	4b09      	ldr	r3, [pc, #36]	; (8008230 <EXTI_u8CLR_pend+0x3c>)
 800820a:	695b      	ldr	r3, [r3, #20]
 800820c:	79fa      	ldrb	r2, [r7, #7]
 800820e:	2101      	movs	r1, #1
 8008210:	fa01 f202 	lsl.w	r2, r1, r2
 8008214:	4611      	mov	r1, r2
 8008216:	4a06      	ldr	r2, [pc, #24]	; (8008230 <EXTI_u8CLR_pend+0x3c>)
 8008218:	430b      	orrs	r3, r1
 800821a:	6153      	str	r3, [r2, #20]
 800821c:	e001      	b.n	8008222 <EXTI_u8CLR_pend+0x2e>
	} else {
		Copy_u8State = NOK;
 800821e:	2301      	movs	r3, #1
 8008220:	73fb      	strb	r3, [r7, #15]
	}
	return Copy_u8State;
 8008222:	7bfb      	ldrb	r3, [r7, #15]
}
 8008224:	4618      	mov	r0, r3
 8008226:	3714      	adds	r7, #20
 8008228:	46bd      	mov	sp, r7
 800822a:	bc80      	pop	{r7}
 800822c:	4770      	bx	lr
 800822e:	bf00      	nop
 8008230:	40010400 	.word	0x40010400

08008234 <EXTI_u8Set_Inturrupt_latch>:

Error_t EXTI_u8Set_Inturrupt_latch(EXTI_Line_t copy_u8Line,
		EXTI_MODE_t copy_u8Mode) {
 8008234:	b480      	push	{r7}
 8008236:	b085      	sub	sp, #20
 8008238:	af00      	add	r7, sp, #0
 800823a:	4603      	mov	r3, r0
 800823c:	460a      	mov	r2, r1
 800823e:	71fb      	strb	r3, [r7, #7]
 8008240:	4613      	mov	r3, r2
 8008242:	71bb      	strb	r3, [r7, #6]
	Error_t Copy_u8State = OK;
 8008244:	2300      	movs	r3, #0
 8008246:	73fb      	strb	r3, [r7, #15]
	if (copy_u8Line < EXTI_TOTAL) {
 8008248:	79fb      	ldrb	r3, [r7, #7]
 800824a:	2b0f      	cmp	r3, #15
 800824c:	d837      	bhi.n	80082be <EXTI_u8Set_Inturrupt_latch+0x8a>
		switch (copy_u8Mode) {
 800824e:	79bb      	ldrb	r3, [r7, #6]
 8008250:	2b02      	cmp	r3, #2
 8008252:	d01c      	beq.n	800828e <EXTI_u8Set_Inturrupt_latch+0x5a>
 8008254:	2b02      	cmp	r3, #2
 8008256:	dc2f      	bgt.n	80082b8 <EXTI_u8Set_Inturrupt_latch+0x84>
 8008258:	2b00      	cmp	r3, #0
 800825a:	d002      	beq.n	8008262 <EXTI_u8Set_Inturrupt_latch+0x2e>
 800825c:	2b01      	cmp	r3, #1
 800825e:	d00b      	beq.n	8008278 <EXTI_u8Set_Inturrupt_latch+0x44>
 8008260:	e02a      	b.n	80082b8 <EXTI_u8Set_Inturrupt_latch+0x84>
		case EXTI_FAILING:
			SET_BIT(EXTI->EXTI_FTSR, copy_u8Line);
 8008262:	4b1b      	ldr	r3, [pc, #108]	; (80082d0 <EXTI_u8Set_Inturrupt_latch+0x9c>)
 8008264:	68db      	ldr	r3, [r3, #12]
 8008266:	79fa      	ldrb	r2, [r7, #7]
 8008268:	2101      	movs	r1, #1
 800826a:	fa01 f202 	lsl.w	r2, r1, r2
 800826e:	4611      	mov	r1, r2
 8008270:	4a17      	ldr	r2, [pc, #92]	; (80082d0 <EXTI_u8Set_Inturrupt_latch+0x9c>)
 8008272:	430b      	orrs	r3, r1
 8008274:	60d3      	str	r3, [r2, #12]
			break;
 8008276:	e024      	b.n	80082c2 <EXTI_u8Set_Inturrupt_latch+0x8e>
		case EXTI_RISING:
			SET_BIT(EXTI->EXTI_RTSR, copy_u8Line);
 8008278:	4b15      	ldr	r3, [pc, #84]	; (80082d0 <EXTI_u8Set_Inturrupt_latch+0x9c>)
 800827a:	689b      	ldr	r3, [r3, #8]
 800827c:	79fa      	ldrb	r2, [r7, #7]
 800827e:	2101      	movs	r1, #1
 8008280:	fa01 f202 	lsl.w	r2, r1, r2
 8008284:	4611      	mov	r1, r2
 8008286:	4a12      	ldr	r2, [pc, #72]	; (80082d0 <EXTI_u8Set_Inturrupt_latch+0x9c>)
 8008288:	430b      	orrs	r3, r1
 800828a:	6093      	str	r3, [r2, #8]
			break;
 800828c:	e019      	b.n	80082c2 <EXTI_u8Set_Inturrupt_latch+0x8e>
		case EXTI_FAILING_RISING:
			SET_BIT(EXTI->EXTI_RTSR, copy_u8Line);
 800828e:	4b10      	ldr	r3, [pc, #64]	; (80082d0 <EXTI_u8Set_Inturrupt_latch+0x9c>)
 8008290:	689b      	ldr	r3, [r3, #8]
 8008292:	79fa      	ldrb	r2, [r7, #7]
 8008294:	2101      	movs	r1, #1
 8008296:	fa01 f202 	lsl.w	r2, r1, r2
 800829a:	4611      	mov	r1, r2
 800829c:	4a0c      	ldr	r2, [pc, #48]	; (80082d0 <EXTI_u8Set_Inturrupt_latch+0x9c>)
 800829e:	430b      	orrs	r3, r1
 80082a0:	6093      	str	r3, [r2, #8]
			SET_BIT(EXTI->EXTI_FTSR, copy_u8Line);
 80082a2:	4b0b      	ldr	r3, [pc, #44]	; (80082d0 <EXTI_u8Set_Inturrupt_latch+0x9c>)
 80082a4:	68db      	ldr	r3, [r3, #12]
 80082a6:	79fa      	ldrb	r2, [r7, #7]
 80082a8:	2101      	movs	r1, #1
 80082aa:	fa01 f202 	lsl.w	r2, r1, r2
 80082ae:	4611      	mov	r1, r2
 80082b0:	4a07      	ldr	r2, [pc, #28]	; (80082d0 <EXTI_u8Set_Inturrupt_latch+0x9c>)
 80082b2:	430b      	orrs	r3, r1
 80082b4:	60d3      	str	r3, [r2, #12]
			break;
 80082b6:	e004      	b.n	80082c2 <EXTI_u8Set_Inturrupt_latch+0x8e>
		default:
			Copy_u8State = NOK;
 80082b8:	2301      	movs	r3, #1
 80082ba:	73fb      	strb	r3, [r7, #15]
			break;
 80082bc:	e001      	b.n	80082c2 <EXTI_u8Set_Inturrupt_latch+0x8e>
		}
	} else {
		Copy_u8State = NOK;
 80082be:	2301      	movs	r3, #1
 80082c0:	73fb      	strb	r3, [r7, #15]
	}
	return Copy_u8State;
 80082c2:	7bfb      	ldrb	r3, [r7, #15]
}
 80082c4:	4618      	mov	r0, r3
 80082c6:	3714      	adds	r7, #20
 80082c8:	46bd      	mov	sp, r7
 80082ca:	bc80      	pop	{r7}
 80082cc:	4770      	bx	lr
 80082ce:	bf00      	nop
 80082d0:	40010400 	.word	0x40010400

080082d4 <EXTI0_IRQHandler>:
/******************************************************************/
/******************************************************************/
/******************************************************************/
// IRQS
void EXTI0_IRQHandler(void) /* EXTI Line0 interrupt */
{
 80082d4:	b580      	push	{r7, lr}
 80082d6:	af00      	add	r7, sp, #0
	EXTI_PtrCallBack[EXTI_Line0]();
 80082d8:	4b03      	ldr	r3, [pc, #12]	; (80082e8 <EXTI0_IRQHandler+0x14>)
 80082da:	681b      	ldr	r3, [r3, #0]
 80082dc:	4798      	blx	r3
	EXTI_u8CLR_pend(EXTI_Line0);
 80082de:	2000      	movs	r0, #0
 80082e0:	f7ff ff88 	bl	80081f4 <EXTI_u8CLR_pend>
}
 80082e4:	bf00      	nop
 80082e6:	bd80      	pop	{r7, pc}
 80082e8:	20000030 	.word	0x20000030

080082ec <EXTI1_IRQHandler>:
/* EXTI Line1 interrupt                             */
void EXTI1_IRQHandler(void) {
 80082ec:	b580      	push	{r7, lr}
 80082ee:	af00      	add	r7, sp, #0
	EXTI_PtrCallBack[EXTI_Line1]();
 80082f0:	4b03      	ldr	r3, [pc, #12]	; (8008300 <EXTI1_IRQHandler+0x14>)
 80082f2:	685b      	ldr	r3, [r3, #4]
 80082f4:	4798      	blx	r3
	EXTI_u8CLR_pend(EXTI_Line1);
 80082f6:	2001      	movs	r0, #1
 80082f8:	f7ff ff7c 	bl	80081f4 <EXTI_u8CLR_pend>

}
 80082fc:	bf00      	nop
 80082fe:	bd80      	pop	{r7, pc}
 8008300:	20000030 	.word	0x20000030

08008304 <EXTI2_IRQHandler>:
/* EXTI Line2 interrupt                             */
void EXTI2_IRQHandler(void) {
 8008304:	b580      	push	{r7, lr}
 8008306:	af00      	add	r7, sp, #0
	EXTI_PtrCallBack[EXTI_Line2]();
 8008308:	4b03      	ldr	r3, [pc, #12]	; (8008318 <EXTI2_IRQHandler+0x14>)
 800830a:	689b      	ldr	r3, [r3, #8]
 800830c:	4798      	blx	r3
	EXTI_u8CLR_pend(EXTI_Line2);
 800830e:	2002      	movs	r0, #2
 8008310:	f7ff ff70 	bl	80081f4 <EXTI_u8CLR_pend>

}
 8008314:	bf00      	nop
 8008316:	bd80      	pop	{r7, pc}
 8008318:	20000030 	.word	0x20000030

0800831c <EXTI3_IRQHandler>:
/* EXTI Line3 interrupt                             */
void EXTI3_IRQHandler(void) {
 800831c:	b580      	push	{r7, lr}
 800831e:	af00      	add	r7, sp, #0
	EXTI_PtrCallBack[EXTI_Line3]();
 8008320:	4b03      	ldr	r3, [pc, #12]	; (8008330 <EXTI3_IRQHandler+0x14>)
 8008322:	68db      	ldr	r3, [r3, #12]
 8008324:	4798      	blx	r3
	EXTI_u8CLR_pend(EXTI_Line3);
 8008326:	2003      	movs	r0, #3
 8008328:	f7ff ff64 	bl	80081f4 <EXTI_u8CLR_pend>

}
 800832c:	bf00      	nop
 800832e:	bd80      	pop	{r7, pc}
 8008330:	20000030 	.word	0x20000030

08008334 <EXTI4_IRQHandler>:
/* EXTI Line4 interrupt                             */
void EXTI4_IRQHandler(void) {
 8008334:	b580      	push	{r7, lr}
 8008336:	af00      	add	r7, sp, #0
	EXTI_PtrCallBack[EXTI_Line4]();
 8008338:	4b03      	ldr	r3, [pc, #12]	; (8008348 <EXTI4_IRQHandler+0x14>)
 800833a:	691b      	ldr	r3, [r3, #16]
 800833c:	4798      	blx	r3
	EXTI_u8CLR_pend(EXTI_Line4);
 800833e:	2004      	movs	r0, #4
 8008340:	f7ff ff58 	bl	80081f4 <EXTI_u8CLR_pend>

}
 8008344:	bf00      	nop
 8008346:	bd80      	pop	{r7, pc}
 8008348:	20000030 	.word	0x20000030

0800834c <EXTI9_5_IRQHandler>:
/* EXTI Line9_5 interrupt */
void EXTI9_5_IRQHandler(void) {
 800834c:	b580      	push	{r7, lr}
 800834e:	af00      	add	r7, sp, #0
	if (READ_BIT(EXTI->EXTI_PR, EXTI_Line5)) {
 8008350:	4b28      	ldr	r3, [pc, #160]	; (80083f4 <EXTI9_5_IRQHandler+0xa8>)
 8008352:	695b      	ldr	r3, [r3, #20]
 8008354:	f003 0320 	and.w	r3, r3, #32
 8008358:	2b00      	cmp	r3, #0
 800835a:	d009      	beq.n	8008370 <EXTI9_5_IRQHandler+0x24>
		if (EXTI_PtrCallBack[EXTI_Line5] != NULLPTR) {
 800835c:	4b26      	ldr	r3, [pc, #152]	; (80083f8 <EXTI9_5_IRQHandler+0xac>)
 800835e:	695b      	ldr	r3, [r3, #20]
 8008360:	2b00      	cmp	r3, #0
 8008362:	d005      	beq.n	8008370 <EXTI9_5_IRQHandler+0x24>
			EXTI_PtrCallBack[EXTI_Line5]();
 8008364:	4b24      	ldr	r3, [pc, #144]	; (80083f8 <EXTI9_5_IRQHandler+0xac>)
 8008366:	695b      	ldr	r3, [r3, #20]
 8008368:	4798      	blx	r3
			EXTI_u8CLR_pend(EXTI_Line5);
 800836a:	2005      	movs	r0, #5
 800836c:	f7ff ff42 	bl	80081f4 <EXTI_u8CLR_pend>

		}
	}
	if (READ_BIT(EXTI->EXTI_PR, EXTI_Line6)) {
 8008370:	4b20      	ldr	r3, [pc, #128]	; (80083f4 <EXTI9_5_IRQHandler+0xa8>)
 8008372:	695b      	ldr	r3, [r3, #20]
 8008374:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8008378:	2b00      	cmp	r3, #0
 800837a:	d009      	beq.n	8008390 <EXTI9_5_IRQHandler+0x44>
		if (EXTI_PtrCallBack[EXTI_Line6] != NULLPTR) {
 800837c:	4b1e      	ldr	r3, [pc, #120]	; (80083f8 <EXTI9_5_IRQHandler+0xac>)
 800837e:	699b      	ldr	r3, [r3, #24]
 8008380:	2b00      	cmp	r3, #0
 8008382:	d005      	beq.n	8008390 <EXTI9_5_IRQHandler+0x44>
			EXTI_PtrCallBack[EXTI_Line6]();
 8008384:	4b1c      	ldr	r3, [pc, #112]	; (80083f8 <EXTI9_5_IRQHandler+0xac>)
 8008386:	699b      	ldr	r3, [r3, #24]
 8008388:	4798      	blx	r3
			EXTI_u8CLR_pend(EXTI_Line6);
 800838a:	2006      	movs	r0, #6
 800838c:	f7ff ff32 	bl	80081f4 <EXTI_u8CLR_pend>

		}
	}
	if (READ_BIT(EXTI->EXTI_PR, EXTI_Line7)) {
 8008390:	4b18      	ldr	r3, [pc, #96]	; (80083f4 <EXTI9_5_IRQHandler+0xa8>)
 8008392:	695b      	ldr	r3, [r3, #20]
 8008394:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8008398:	2b00      	cmp	r3, #0
 800839a:	d009      	beq.n	80083b0 <EXTI9_5_IRQHandler+0x64>
		if (EXTI_PtrCallBack[EXTI_Line7] != NULLPTR) {
 800839c:	4b16      	ldr	r3, [pc, #88]	; (80083f8 <EXTI9_5_IRQHandler+0xac>)
 800839e:	69db      	ldr	r3, [r3, #28]
 80083a0:	2b00      	cmp	r3, #0
 80083a2:	d005      	beq.n	80083b0 <EXTI9_5_IRQHandler+0x64>
			EXTI_PtrCallBack[EXTI_Line7]();
 80083a4:	4b14      	ldr	r3, [pc, #80]	; (80083f8 <EXTI9_5_IRQHandler+0xac>)
 80083a6:	69db      	ldr	r3, [r3, #28]
 80083a8:	4798      	blx	r3
			EXTI_u8CLR_pend(EXTI_Line7);
 80083aa:	2007      	movs	r0, #7
 80083ac:	f7ff ff22 	bl	80081f4 <EXTI_u8CLR_pend>

		}
	}
	if (READ_BIT(EXTI->EXTI_PR, EXTI_Line8)) {
 80083b0:	4b10      	ldr	r3, [pc, #64]	; (80083f4 <EXTI9_5_IRQHandler+0xa8>)
 80083b2:	695b      	ldr	r3, [r3, #20]
 80083b4:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80083b8:	2b00      	cmp	r3, #0
 80083ba:	d009      	beq.n	80083d0 <EXTI9_5_IRQHandler+0x84>
		if (EXTI_PtrCallBack[EXTI_Line8] != NULLPTR) {
 80083bc:	4b0e      	ldr	r3, [pc, #56]	; (80083f8 <EXTI9_5_IRQHandler+0xac>)
 80083be:	6a1b      	ldr	r3, [r3, #32]
 80083c0:	2b00      	cmp	r3, #0
 80083c2:	d005      	beq.n	80083d0 <EXTI9_5_IRQHandler+0x84>
			EXTI_PtrCallBack[EXTI_Line8]();
 80083c4:	4b0c      	ldr	r3, [pc, #48]	; (80083f8 <EXTI9_5_IRQHandler+0xac>)
 80083c6:	6a1b      	ldr	r3, [r3, #32]
 80083c8:	4798      	blx	r3
			EXTI_u8CLR_pend(EXTI_Line8);
 80083ca:	2008      	movs	r0, #8
 80083cc:	f7ff ff12 	bl	80081f4 <EXTI_u8CLR_pend>

		}
	}
	if (READ_BIT(EXTI->EXTI_PR, EXTI_Line9)) {
 80083d0:	4b08      	ldr	r3, [pc, #32]	; (80083f4 <EXTI9_5_IRQHandler+0xa8>)
 80083d2:	695b      	ldr	r3, [r3, #20]
 80083d4:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80083d8:	2b00      	cmp	r3, #0
 80083da:	d009      	beq.n	80083f0 <EXTI9_5_IRQHandler+0xa4>
		if (EXTI_PtrCallBack[EXTI_Line9] != NULLPTR) {
 80083dc:	4b06      	ldr	r3, [pc, #24]	; (80083f8 <EXTI9_5_IRQHandler+0xac>)
 80083de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80083e0:	2b00      	cmp	r3, #0
 80083e2:	d005      	beq.n	80083f0 <EXTI9_5_IRQHandler+0xa4>
			EXTI_PtrCallBack[EXTI_Line9]();
 80083e4:	4b04      	ldr	r3, [pc, #16]	; (80083f8 <EXTI9_5_IRQHandler+0xac>)
 80083e6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80083e8:	4798      	blx	r3
			EXTI_u8CLR_pend(EXTI_Line9);
 80083ea:	2009      	movs	r0, #9
 80083ec:	f7ff ff02 	bl	80081f4 <EXTI_u8CLR_pend>

		}
	}
}
 80083f0:	bf00      	nop
 80083f2:	bd80      	pop	{r7, pc}
 80083f4:	40010400 	.word	0x40010400
 80083f8:	20000030 	.word	0x20000030

080083fc <EXTI15_10_IRQHandler>:

/* EXTI Line15_10 interrupt */
void EXTI15_10_IRQHandler(void) {
 80083fc:	b580      	push	{r7, lr}
 80083fe:	af00      	add	r7, sp, #0
	if (READ_BIT(EXTI->EXTI_PR, EXTI_Line10)) {
 8008400:	4b30      	ldr	r3, [pc, #192]	; (80084c4 <EXTI15_10_IRQHandler+0xc8>)
 8008402:	695b      	ldr	r3, [r3, #20]
 8008404:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8008408:	2b00      	cmp	r3, #0
 800840a:	d009      	beq.n	8008420 <EXTI15_10_IRQHandler+0x24>
		if (EXTI_PtrCallBack[EXTI_Line10] != NULLPTR) {
 800840c:	4b2e      	ldr	r3, [pc, #184]	; (80084c8 <EXTI15_10_IRQHandler+0xcc>)
 800840e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008410:	2b00      	cmp	r3, #0
 8008412:	d005      	beq.n	8008420 <EXTI15_10_IRQHandler+0x24>
			EXTI_PtrCallBack[EXTI_Line10]();
 8008414:	4b2c      	ldr	r3, [pc, #176]	; (80084c8 <EXTI15_10_IRQHandler+0xcc>)
 8008416:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008418:	4798      	blx	r3
			EXTI_u8CLR_pend(EXTI_Line10);
 800841a:	200a      	movs	r0, #10
 800841c:	f7ff feea 	bl	80081f4 <EXTI_u8CLR_pend>
		}
	}
	if (READ_BIT(EXTI->EXTI_PR, EXTI_Line11)) {
 8008420:	4b28      	ldr	r3, [pc, #160]	; (80084c4 <EXTI15_10_IRQHandler+0xc8>)
 8008422:	695b      	ldr	r3, [r3, #20]
 8008424:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8008428:	2b00      	cmp	r3, #0
 800842a:	d009      	beq.n	8008440 <EXTI15_10_IRQHandler+0x44>
		if (EXTI_PtrCallBack[EXTI_Line11] != NULLPTR) {
 800842c:	4b26      	ldr	r3, [pc, #152]	; (80084c8 <EXTI15_10_IRQHandler+0xcc>)
 800842e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8008430:	2b00      	cmp	r3, #0
 8008432:	d005      	beq.n	8008440 <EXTI15_10_IRQHandler+0x44>
			EXTI_PtrCallBack[EXTI_Line11]();
 8008434:	4b24      	ldr	r3, [pc, #144]	; (80084c8 <EXTI15_10_IRQHandler+0xcc>)
 8008436:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8008438:	4798      	blx	r3
			EXTI_u8CLR_pend(EXTI_Line11);
 800843a:	200b      	movs	r0, #11
 800843c:	f7ff feda 	bl	80081f4 <EXTI_u8CLR_pend>
		}
	}
	if (READ_BIT(EXTI->EXTI_PR, EXTI_Line12)) {
 8008440:	4b20      	ldr	r3, [pc, #128]	; (80084c4 <EXTI15_10_IRQHandler+0xc8>)
 8008442:	695b      	ldr	r3, [r3, #20]
 8008444:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8008448:	2b00      	cmp	r3, #0
 800844a:	d009      	beq.n	8008460 <EXTI15_10_IRQHandler+0x64>
		if (EXTI_PtrCallBack[EXTI_Line12] != NULLPTR) {
 800844c:	4b1e      	ldr	r3, [pc, #120]	; (80084c8 <EXTI15_10_IRQHandler+0xcc>)
 800844e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008450:	2b00      	cmp	r3, #0
 8008452:	d005      	beq.n	8008460 <EXTI15_10_IRQHandler+0x64>
			EXTI_PtrCallBack[EXTI_Line12]();
 8008454:	4b1c      	ldr	r3, [pc, #112]	; (80084c8 <EXTI15_10_IRQHandler+0xcc>)
 8008456:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8008458:	4798      	blx	r3
			EXTI_u8CLR_pend(EXTI_Line12);
 800845a:	200c      	movs	r0, #12
 800845c:	f7ff feca 	bl	80081f4 <EXTI_u8CLR_pend>
		}
	}
	if (READ_BIT(EXTI->EXTI_PR, EXTI_Line13)) {
 8008460:	4b18      	ldr	r3, [pc, #96]	; (80084c4 <EXTI15_10_IRQHandler+0xc8>)
 8008462:	695b      	ldr	r3, [r3, #20]
 8008464:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8008468:	2b00      	cmp	r3, #0
 800846a:	d009      	beq.n	8008480 <EXTI15_10_IRQHandler+0x84>
		if (EXTI_PtrCallBack[EXTI_Line13] != NULLPTR) {
 800846c:	4b16      	ldr	r3, [pc, #88]	; (80084c8 <EXTI15_10_IRQHandler+0xcc>)
 800846e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008470:	2b00      	cmp	r3, #0
 8008472:	d005      	beq.n	8008480 <EXTI15_10_IRQHandler+0x84>
			EXTI_PtrCallBack[EXTI_Line13]();
 8008474:	4b14      	ldr	r3, [pc, #80]	; (80084c8 <EXTI15_10_IRQHandler+0xcc>)
 8008476:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008478:	4798      	blx	r3
			EXTI_u8CLR_pend(EXTI_Line13);
 800847a:	200d      	movs	r0, #13
 800847c:	f7ff feba 	bl	80081f4 <EXTI_u8CLR_pend>
		}
	}
	if (READ_BIT(EXTI->EXTI_PR, EXTI_Line14)) {
 8008480:	4b10      	ldr	r3, [pc, #64]	; (80084c4 <EXTI15_10_IRQHandler+0xc8>)
 8008482:	695b      	ldr	r3, [r3, #20]
 8008484:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8008488:	2b00      	cmp	r3, #0
 800848a:	d009      	beq.n	80084a0 <EXTI15_10_IRQHandler+0xa4>
		if (EXTI_PtrCallBack[EXTI_Line14] != NULLPTR) {
 800848c:	4b0e      	ldr	r3, [pc, #56]	; (80084c8 <EXTI15_10_IRQHandler+0xcc>)
 800848e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8008490:	2b00      	cmp	r3, #0
 8008492:	d005      	beq.n	80084a0 <EXTI15_10_IRQHandler+0xa4>
			EXTI_PtrCallBack[EXTI_Line14]();
 8008494:	4b0c      	ldr	r3, [pc, #48]	; (80084c8 <EXTI15_10_IRQHandler+0xcc>)
 8008496:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8008498:	4798      	blx	r3
			EXTI_u8CLR_pend(EXTI_Line14);
 800849a:	200e      	movs	r0, #14
 800849c:	f7ff feaa 	bl	80081f4 <EXTI_u8CLR_pend>
		}
	}
	if (READ_BIT(EXTI->EXTI_PR, EXTI_Line15)) {
 80084a0:	4b08      	ldr	r3, [pc, #32]	; (80084c4 <EXTI15_10_IRQHandler+0xc8>)
 80084a2:	695b      	ldr	r3, [r3, #20]
 80084a4:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80084a8:	2b00      	cmp	r3, #0
 80084aa:	d009      	beq.n	80084c0 <EXTI15_10_IRQHandler+0xc4>
		if (EXTI_PtrCallBack[EXTI_Line15] != NULLPTR) {
 80084ac:	4b06      	ldr	r3, [pc, #24]	; (80084c8 <EXTI15_10_IRQHandler+0xcc>)
 80084ae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80084b0:	2b00      	cmp	r3, #0
 80084b2:	d005      	beq.n	80084c0 <EXTI15_10_IRQHandler+0xc4>
			EXTI_PtrCallBack[EXTI_Line15]();
 80084b4:	4b04      	ldr	r3, [pc, #16]	; (80084c8 <EXTI15_10_IRQHandler+0xcc>)
 80084b6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80084b8:	4798      	blx	r3
			EXTI_u8CLR_pend(EXTI_Line15);
 80084ba:	200f      	movs	r0, #15
 80084bc:	f7ff fe9a 	bl	80081f4 <EXTI_u8CLR_pend>
		}
	}
}
 80084c0:	bf00      	nop
 80084c2:	bd80      	pop	{r7, pc}
 80084c4:	40010400 	.word	0x40010400
 80084c8:	20000030 	.word	0x20000030

080084cc <FLASH_enWaitClr>:
		*Ptr_u16ReturnData = Local_calculatedData;
	}

	return Local_state;
}
FLASH_enERR_T FLASH_enWaitClr() {
 80084cc:	b480      	push	{r7}
 80084ce:	b083      	sub	sp, #12
 80084d0:	af00      	add	r7, sp, #0
	FLASH_enERR_T Local_state = FLASH_OK;
 80084d2:	2300      	movs	r3, #0
 80084d4:	71fb      	strb	r3, [r7, #7]
	while (READ_BIT(FLASH->FLASH_SR, SR_BSY))
 80084d6:	bf00      	nop
 80084d8:	4b17      	ldr	r3, [pc, #92]	; (8008538 <FLASH_enWaitClr+0x6c>)
 80084da:	68db      	ldr	r3, [r3, #12]
 80084dc:	f003 0301 	and.w	r3, r3, #1
 80084e0:	2b00      	cmp	r3, #0
 80084e2:	d1f9      	bne.n	80084d8 <FLASH_enWaitClr+0xc>
		; // Wait while the flash is busy
	if (READ_BIT(FLASH->FLASH_SR, SR_EOP)) // Check if End of Operation flag is set
 80084e4:	4b14      	ldr	r3, [pc, #80]	; (8008538 <FLASH_enWaitClr+0x6c>)
 80084e6:	68db      	ldr	r3, [r3, #12]
 80084e8:	f003 0301 	and.w	r3, r3, #1
 80084ec:	2b00      	cmp	r3, #0
 80084ee:	d005      	beq.n	80084fc <FLASH_enWaitClr+0x30>
		SET_BIT(FLASH->FLASH_SR, SR_EOP);    // Clear the flag
 80084f0:	4b11      	ldr	r3, [pc, #68]	; (8008538 <FLASH_enWaitClr+0x6c>)
 80084f2:	68db      	ldr	r3, [r3, #12]
 80084f4:	4a10      	ldr	r2, [pc, #64]	; (8008538 <FLASH_enWaitClr+0x6c>)
 80084f6:	f043 0301 	orr.w	r3, r3, #1
 80084fa:	60d3      	str	r3, [r2, #12]
	if (READ_BIT(FLASH->FLASH_SR, SR_PGERR)) // Check for programming error
 80084fc:	4b0e      	ldr	r3, [pc, #56]	; (8008538 <FLASH_enWaitClr+0x6c>)
 80084fe:	68db      	ldr	r3, [r3, #12]
 8008500:	f003 0301 	and.w	r3, r3, #1
 8008504:	2b00      	cmp	r3, #0
 8008506:	d005      	beq.n	8008514 <FLASH_enWaitClr+0x48>
		SET_BIT(FLASH->FLASH_SR, SR_PGERR);       // Clear the flag
 8008508:	4b0b      	ldr	r3, [pc, #44]	; (8008538 <FLASH_enWaitClr+0x6c>)
 800850a:	68db      	ldr	r3, [r3, #12]
 800850c:	4a0a      	ldr	r2, [pc, #40]	; (8008538 <FLASH_enWaitClr+0x6c>)
 800850e:	f043 0301 	orr.w	r3, r3, #1
 8008512:	60d3      	str	r3, [r2, #12]
	if (READ_BIT(FLASH->FLASH_SR, SR_WRPRTERR)) // Check for write protection error
 8008514:	4b08      	ldr	r3, [pc, #32]	; (8008538 <FLASH_enWaitClr+0x6c>)
 8008516:	68db      	ldr	r3, [r3, #12]
 8008518:	f003 0301 	and.w	r3, r3, #1
 800851c:	2b00      	cmp	r3, #0
 800851e:	d005      	beq.n	800852c <FLASH_enWaitClr+0x60>
		SET_BIT(FLASH->FLASH_SR, SR_WRPRTERR);  // Clear the flag
 8008520:	4b05      	ldr	r3, [pc, #20]	; (8008538 <FLASH_enWaitClr+0x6c>)
 8008522:	68db      	ldr	r3, [r3, #12]
 8008524:	4a04      	ldr	r2, [pc, #16]	; (8008538 <FLASH_enWaitClr+0x6c>)
 8008526:	f043 0301 	orr.w	r3, r3, #1
 800852a:	60d3      	str	r3, [r2, #12]

	return Local_state;
 800852c:	79fb      	ldrb	r3, [r7, #7]
}
 800852e:	4618      	mov	r0, r3
 8008530:	370c      	adds	r7, #12
 8008532:	46bd      	mov	sp, r7
 8008534:	bc80      	pop	{r7}
 8008536:	4770      	bx	lr
 8008538:	40022000 	.word	0x40022000

0800853c <FLASH_enWriteData>:
		//do nothing
	}
	return Local_state;
}

FLASH_enERR_T FLASH_enWriteData(u32 ptrAddress, u16 Copy_u8Data) {
 800853c:	b580      	push	{r7, lr}
 800853e:	b084      	sub	sp, #16
 8008540:	af00      	add	r7, sp, #0
 8008542:	6078      	str	r0, [r7, #4]
 8008544:	460b      	mov	r3, r1
 8008546:	807b      	strh	r3, [r7, #2]

	FLASH_enERR_T Local_state = FLASH_OK;
 8008548:	2300      	movs	r3, #0
 800854a:	73fb      	strb	r3, [r7, #15]
	Local_state = FLASH_enUnlock();
 800854c:	f000 f858 	bl	8008600 <FLASH_enUnlock>
 8008550:	4603      	mov	r3, r0
 8008552:	73fb      	strb	r3, [r7, #15]

	if (*(volatile u32*) ptrAddress != 0xffffffff) {
 8008554:	687b      	ldr	r3, [r7, #4]
 8008556:	681b      	ldr	r3, [r3, #0]
 8008558:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800855c:	d002      	beq.n	8008564 <FLASH_enWriteData+0x28>

		Local_state = FLASH_WRITTEN;
 800855e:	2301      	movs	r3, #1
 8008560:	73fb      	strb	r3, [r7, #15]
 8008562:	e01d      	b.n	80085a0 <FLASH_enWriteData+0x64>
	} else {
		FLASH_enWaitClr();         // wait and clr
 8008564:	f7ff ffb2 	bl	80084cc <FLASH_enWaitClr>
		if (Local_state == FLASH_OK) {
 8008568:	7bfb      	ldrb	r3, [r7, #15]
 800856a:	2b00      	cmp	r3, #0
 800856c:	d103      	bne.n	8008576 <FLASH_enWriteData+0x3a>
			Local_state = FlASH_enEnablePrograming();
 800856e:	f000 f81f 	bl	80085b0 <FlASH_enEnablePrograming>
 8008572:	4603      	mov	r3, r0
 8008574:	73fb      	strb	r3, [r7, #15]
		} else {
			//do nothing
		}
		//Write Data on flash location
		//check on location
		if ((ptrAddress) > FLASH_START && (ptrAddress) < FLASH_END
 8008576:	687b      	ldr	r3, [r7, #4]
 8008578:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800857c:	d90a      	bls.n	8008594 <FLASH_enWriteData+0x58>
 800857e:	687b      	ldr	r3, [r7, #4]
 8008580:	4a0a      	ldr	r2, [pc, #40]	; (80085ac <FLASH_enWriteData+0x70>)
 8008582:	4293      	cmp	r3, r2
 8008584:	d206      	bcs.n	8008594 <FLASH_enWriteData+0x58>
				&& Local_state == FLASH_OK) {
 8008586:	7bfb      	ldrb	r3, [r7, #15]
 8008588:	2b00      	cmp	r3, #0
 800858a:	d103      	bne.n	8008594 <FLASH_enWriteData+0x58>
			*(volatile u16*) ptrAddress = Copy_u8Data;
 800858c:	687b      	ldr	r3, [r7, #4]
 800858e:	887a      	ldrh	r2, [r7, #2]
 8008590:	801a      	strh	r2, [r3, #0]
 8008592:	e001      	b.n	8008598 <FLASH_enWriteData+0x5c>

		} else {

			//out of range
			Local_state = FLASH_OUTOFRANGE;
 8008594:	2302      	movs	r3, #2
 8008596:	73fb      	strb	r3, [r7, #15]
		}

		FLASH_enWaitClr();         // wait and clr
 8008598:	f7ff ff98 	bl	80084cc <FLASH_enWaitClr>

		FlASH_enDisablePrograming();
 800859c:	f000 f81c 	bl	80085d8 <FlASH_enDisablePrograming>
	}

	return Local_state;
 80085a0:	7bfb      	ldrb	r3, [r7, #15]

}
 80085a2:	4618      	mov	r0, r3
 80085a4:	3710      	adds	r7, #16
 80085a6:	46bd      	mov	sp, r7
 80085a8:	bd80      	pop	{r7, pc}
 80085aa:	bf00      	nop
 80085ac:	0807ffff 	.word	0x0807ffff

080085b0 <FlASH_enEnablePrograming>:

	return Local_state;
}

// enable flash programming by set PG bit
FLASH_enERR_T FlASH_enEnablePrograming() {
 80085b0:	b480      	push	{r7}
 80085b2:	b083      	sub	sp, #12
 80085b4:	af00      	add	r7, sp, #0
	FLASH_enERR_T Local_state = FLASH_OK;
 80085b6:	2300      	movs	r3, #0
 80085b8:	71fb      	strb	r3, [r7, #7]
	SET_BIT(FLASH->FLASH_CR, CR_PG);
 80085ba:	4b06      	ldr	r3, [pc, #24]	; (80085d4 <FlASH_enEnablePrograming+0x24>)
 80085bc:	691b      	ldr	r3, [r3, #16]
 80085be:	4a05      	ldr	r2, [pc, #20]	; (80085d4 <FlASH_enEnablePrograming+0x24>)
 80085c0:	f043 0301 	orr.w	r3, r3, #1
 80085c4:	6113      	str	r3, [r2, #16]
	return Local_state;
 80085c6:	79fb      	ldrb	r3, [r7, #7]
}
 80085c8:	4618      	mov	r0, r3
 80085ca:	370c      	adds	r7, #12
 80085cc:	46bd      	mov	sp, r7
 80085ce:	bc80      	pop	{r7}
 80085d0:	4770      	bx	lr
 80085d2:	bf00      	nop
 80085d4:	40022000 	.word	0x40022000

080085d8 <FlASH_enDisablePrograming>:

// disable flash programming by set PG bit
FLASH_enERR_T FlASH_enDisablePrograming() {
 80085d8:	b480      	push	{r7}
 80085da:	b083      	sub	sp, #12
 80085dc:	af00      	add	r7, sp, #0
	FLASH_enERR_T Local_state = FLASH_OK;
 80085de:	2300      	movs	r3, #0
 80085e0:	71fb      	strb	r3, [r7, #7]
	CLR_BIT(FLASH->FLASH_CR, CR_PG);
 80085e2:	4b06      	ldr	r3, [pc, #24]	; (80085fc <FlASH_enDisablePrograming+0x24>)
 80085e4:	691b      	ldr	r3, [r3, #16]
 80085e6:	4a05      	ldr	r2, [pc, #20]	; (80085fc <FlASH_enDisablePrograming+0x24>)
 80085e8:	f023 0301 	bic.w	r3, r3, #1
 80085ec:	6113      	str	r3, [r2, #16]
	return Local_state;
 80085ee:	79fb      	ldrb	r3, [r7, #7]
}
 80085f0:	4618      	mov	r0, r3
 80085f2:	370c      	adds	r7, #12
 80085f4:	46bd      	mov	sp, r7
 80085f6:	bc80      	pop	{r7}
 80085f8:	4770      	bx	lr
 80085fa:	bf00      	nop
 80085fc:	40022000 	.word	0x40022000

08008600 <FLASH_enUnlock>:

FLASH_enERR_T FLASH_enUnlock() {
 8008600:	b480      	push	{r7}
 8008602:	b083      	sub	sp, #12
 8008604:	af00      	add	r7, sp, #0
	FLASH_enERR_T Local_state = FLASH_OK;
 8008606:	2300      	movs	r3, #0
 8008608:	71fb      	strb	r3, [r7, #7]
	u8 local_FlashLockStatus = READ_BIT(FLASH->FLASH_CR, CR_LOCK);
 800860a:	4b12      	ldr	r3, [pc, #72]	; (8008654 <FLASH_enUnlock+0x54>)
 800860c:	691b      	ldr	r3, [r3, #16]
 800860e:	09db      	lsrs	r3, r3, #7
 8008610:	b2db      	uxtb	r3, r3
 8008612:	f003 0301 	and.w	r3, r3, #1
 8008616:	71bb      	strb	r3, [r7, #6]
	if (local_FlashLockStatus == 1) // flash is locked
 8008618:	79bb      	ldrb	r3, [r7, #6]
 800861a:	2b01      	cmp	r3, #1
 800861c:	d105      	bne.n	800862a <FLASH_enUnlock+0x2a>
			{
		// unlock sequance
		FLASH->FLASH_KEYR = FLASH_KEY1;
 800861e:	4b0d      	ldr	r3, [pc, #52]	; (8008654 <FLASH_enUnlock+0x54>)
 8008620:	4a0d      	ldr	r2, [pc, #52]	; (8008658 <FLASH_enUnlock+0x58>)
 8008622:	605a      	str	r2, [r3, #4]
		FLASH->FLASH_KEYR = FLASH_KEY2;
 8008624:	4b0b      	ldr	r3, [pc, #44]	; (8008654 <FLASH_enUnlock+0x54>)
 8008626:	4a0d      	ldr	r2, [pc, #52]	; (800865c <FLASH_enUnlock+0x5c>)
 8008628:	605a      	str	r2, [r3, #4]

	} else {
		//dp noting
	}
	 local_FlashLockStatus = READ_BIT(FLASH->FLASH_CR, CR_LOCK);
 800862a:	4b0a      	ldr	r3, [pc, #40]	; (8008654 <FLASH_enUnlock+0x54>)
 800862c:	691b      	ldr	r3, [r3, #16]
 800862e:	09db      	lsrs	r3, r3, #7
 8008630:	b2db      	uxtb	r3, r3
 8008632:	f003 0301 	and.w	r3, r3, #1
 8008636:	71bb      	strb	r3, [r7, #6]

	if (local_FlashLockStatus == 1) {
 8008638:	79bb      	ldrb	r3, [r7, #6]
 800863a:	2b01      	cmp	r3, #1
 800863c:	d102      	bne.n	8008644 <FLASH_enUnlock+0x44>

		Local_state = FLASH_UNLOCKERR;
 800863e:	2303      	movs	r3, #3
 8008640:	71fb      	strb	r3, [r7, #7]
 8008642:	e001      	b.n	8008648 <FLASH_enUnlock+0x48>
	} else {

		Local_state = FLASH_OK;
 8008644:	2300      	movs	r3, #0
 8008646:	71fb      	strb	r3, [r7, #7]

	}
	return Local_state;
 8008648:	79fb      	ldrb	r3, [r7, #7]
}
 800864a:	4618      	mov	r0, r3
 800864c:	370c      	adds	r7, #12
 800864e:	46bd      	mov	sp, r7
 8008650:	bc80      	pop	{r7}
 8008652:	4770      	bx	lr
 8008654:	40022000 	.word	0x40022000
 8008658:	45670123 	.word	0x45670123
 800865c:	cdef89ab 	.word	0xcdef89ab

08008660 <GPIO_u8Init>:
#include "GPIO_Private.h"
#include "GPIO_Interface.h"

extern GPIO_Conf_t GPIO_Conf_ARR[PINTOTAL];

Error_t GPIO_u8Init() {
 8008660:	b580      	push	{r7, lr}
 8008662:	b082      	sub	sp, #8
 8008664:	af00      	add	r7, sp, #0

	for (u8 index = 0; index < PINTOTAL; index++) {
 8008666:	2300      	movs	r3, #0
 8008668:	71fb      	strb	r3, [r7, #7]
 800866a:	e00f      	b.n	800868c <GPIO_u8Init+0x2c>
		GPIO_u8SetPinD_ID(GPIO_Conf_ARR[index].GPIO_u8_pin,
 800866c:	79fb      	ldrb	r3, [r7, #7]
 800866e:	4a0b      	ldr	r2, [pc, #44]	; (800869c <GPIO_u8Init+0x3c>)
 8008670:	f812 2013 	ldrb.w	r2, [r2, r3, lsl #1]
 8008674:	79fb      	ldrb	r3, [r7, #7]
 8008676:	4909      	ldr	r1, [pc, #36]	; (800869c <GPIO_u8Init+0x3c>)
 8008678:	005b      	lsls	r3, r3, #1
 800867a:	440b      	add	r3, r1
 800867c:	785b      	ldrb	r3, [r3, #1]
 800867e:	4619      	mov	r1, r3
 8008680:	4610      	mov	r0, r2
 8008682:	f000 f80d 	bl	80086a0 <GPIO_u8SetPinD_ID>
	for (u8 index = 0; index < PINTOTAL; index++) {
 8008686:	79fb      	ldrb	r3, [r7, #7]
 8008688:	3301      	adds	r3, #1
 800868a:	71fb      	strb	r3, [r7, #7]
 800868c:	79fb      	ldrb	r3, [r7, #7]
 800868e:	2b2f      	cmp	r3, #47	; 0x2f
 8008690:	d9ec      	bls.n	800866c <GPIO_u8Init+0xc>
				GPIO_Conf_ARR[index].GPIO_u8_Mode);
	}
	return OK;
 8008692:	2300      	movs	r3, #0
}
 8008694:	4618      	mov	r0, r3
 8008696:	3708      	adds	r7, #8
 8008698:	46bd      	mov	sp, r7
 800869a:	bd80      	pop	{r7, pc}
 800869c:	08009358 	.word	0x08009358

080086a0 <GPIO_u8SetPinD_ID>:
		local_state = NOK;
		break;
	}
	return local_state;
}
Error_t GPIO_u8SetPinD_ID(GPIO_u8PIN_t Copy_u8PinId, u8 Copy_u8Mode) {
 80086a0:	b480      	push	{r7}
 80086a2:	b085      	sub	sp, #20
 80086a4:	af00      	add	r7, sp, #0
 80086a6:	4603      	mov	r3, r0
 80086a8:	460a      	mov	r2, r1
 80086aa:	71fb      	strb	r3, [r7, #7]
 80086ac:	4613      	mov	r3, r2
 80086ae:	71bb      	strb	r3, [r7, #6]
	u8 local_port = (Copy_u8PinId / GPIO_u8R_PINS) + 1;
 80086b0:	79fb      	ldrb	r3, [r7, #7]
 80086b2:	091b      	lsrs	r3, r3, #4
 80086b4:	b2db      	uxtb	r3, r3
 80086b6:	3301      	adds	r3, #1
 80086b8:	73bb      	strb	r3, [r7, #14]
	u8 local_pin = Copy_u8PinId % GPIO_u8R_PINS;
 80086ba:	79fb      	ldrb	r3, [r7, #7]
 80086bc:	f003 030f 	and.w	r3, r3, #15
 80086c0:	737b      	strb	r3, [r7, #13]
	Error_t local_state = OK;
 80086c2:	2300      	movs	r3, #0
 80086c4:	73fb      	strb	r3, [r7, #15]
	switch (local_port) {
 80086c6:	7bbb      	ldrb	r3, [r7, #14]
 80086c8:	2b03      	cmp	r3, #3
 80086ca:	d07d      	beq.n	80087c8 <GPIO_u8SetPinD_ID+0x128>
 80086cc:	2b03      	cmp	r3, #3
 80086ce:	f300 80b6 	bgt.w	800883e <GPIO_u8SetPinD_ID+0x19e>
 80086d2:	2b01      	cmp	r3, #1
 80086d4:	d002      	beq.n	80086dc <GPIO_u8SetPinD_ID+0x3c>
 80086d6:	2b02      	cmp	r3, #2
 80086d8:	d03b      	beq.n	8008752 <GPIO_u8SetPinD_ID+0xb2>
 80086da:	e0b0      	b.n	800883e <GPIO_u8SetPinD_ID+0x19e>
	case GPIO_PORTA:
		if (local_pin <= GPIO_u8f_REG_LEN) {
 80086dc:	7b7b      	ldrb	r3, [r7, #13]
 80086de:	2b07      	cmp	r3, #7
 80086e0:	d817      	bhi.n	8008712 <GPIO_u8SetPinD_ID+0x72>
			GPIO_A->GPIO_CRL &= ~((GPIO_u8CLR_MASK)
 80086e2:	4b5b      	ldr	r3, [pc, #364]	; (8008850 <GPIO_u8SetPinD_ID+0x1b0>)
 80086e4:	681b      	ldr	r3, [r3, #0]
					<< (local_pin * GPIO_u8PIN_REG_SIZE));
 80086e6:	7b7a      	ldrb	r2, [r7, #13]
 80086e8:	0092      	lsls	r2, r2, #2
 80086ea:	210f      	movs	r1, #15
 80086ec:	fa01 f202 	lsl.w	r2, r1, r2
			GPIO_A->GPIO_CRL &= ~((GPIO_u8CLR_MASK)
 80086f0:	43d2      	mvns	r2, r2
 80086f2:	4611      	mov	r1, r2
 80086f4:	4a56      	ldr	r2, [pc, #344]	; (8008850 <GPIO_u8SetPinD_ID+0x1b0>)
 80086f6:	400b      	ands	r3, r1
 80086f8:	6013      	str	r3, [r2, #0]
			GPIO_A->GPIO_CRL |= ((Copy_u8Mode)
 80086fa:	4b55      	ldr	r3, [pc, #340]	; (8008850 <GPIO_u8SetPinD_ID+0x1b0>)
 80086fc:	681b      	ldr	r3, [r3, #0]
					<< (local_pin * GPIO_u8PIN_REG_SIZE));
 80086fe:	79b9      	ldrb	r1, [r7, #6]
 8008700:	7b7a      	ldrb	r2, [r7, #13]
 8008702:	0092      	lsls	r2, r2, #2
 8008704:	fa01 f202 	lsl.w	r2, r1, r2
 8008708:	4611      	mov	r1, r2
			GPIO_A->GPIO_CRL |= ((Copy_u8Mode)
 800870a:	4a51      	ldr	r2, [pc, #324]	; (8008850 <GPIO_u8SetPinD_ID+0x1b0>)
 800870c:	430b      	orrs	r3, r1
 800870e:	6013      	str	r3, [r2, #0]
			GPIO_A->GPIO_CRH |= ((Copy_u8Mode)
					<< ((local_pin - GPIO_u8OFSET) * GPIO_u8PIN_REG_SIZE));
		} else {
			local_state = NOK;
		}
		break;
 8008710:	e098      	b.n	8008844 <GPIO_u8SetPinD_ID+0x1a4>
		} else if (local_pin <= GPIO_u8L_REG_LEN) {
 8008712:	7b7b      	ldrb	r3, [r7, #13]
 8008714:	2b0f      	cmp	r3, #15
 8008716:	d819      	bhi.n	800874c <GPIO_u8SetPinD_ID+0xac>
			GPIO_A->GPIO_CRH &= ~((GPIO_u8CLR_MASK)
 8008718:	4b4d      	ldr	r3, [pc, #308]	; (8008850 <GPIO_u8SetPinD_ID+0x1b0>)
 800871a:	685b      	ldr	r3, [r3, #4]
					<< ((local_pin - GPIO_u8OFSET) * GPIO_u8PIN_REG_SIZE));
 800871c:	7b7a      	ldrb	r2, [r7, #13]
 800871e:	3a08      	subs	r2, #8
 8008720:	0092      	lsls	r2, r2, #2
 8008722:	210f      	movs	r1, #15
 8008724:	fa01 f202 	lsl.w	r2, r1, r2
			GPIO_A->GPIO_CRH &= ~((GPIO_u8CLR_MASK)
 8008728:	43d2      	mvns	r2, r2
 800872a:	4611      	mov	r1, r2
 800872c:	4a48      	ldr	r2, [pc, #288]	; (8008850 <GPIO_u8SetPinD_ID+0x1b0>)
 800872e:	400b      	ands	r3, r1
 8008730:	6053      	str	r3, [r2, #4]
			GPIO_A->GPIO_CRH |= ((Copy_u8Mode)
 8008732:	4b47      	ldr	r3, [pc, #284]	; (8008850 <GPIO_u8SetPinD_ID+0x1b0>)
 8008734:	685b      	ldr	r3, [r3, #4]
					<< ((local_pin - GPIO_u8OFSET) * GPIO_u8PIN_REG_SIZE));
 8008736:	79b9      	ldrb	r1, [r7, #6]
 8008738:	7b7a      	ldrb	r2, [r7, #13]
 800873a:	3a08      	subs	r2, #8
 800873c:	0092      	lsls	r2, r2, #2
 800873e:	fa01 f202 	lsl.w	r2, r1, r2
 8008742:	4611      	mov	r1, r2
			GPIO_A->GPIO_CRH |= ((Copy_u8Mode)
 8008744:	4a42      	ldr	r2, [pc, #264]	; (8008850 <GPIO_u8SetPinD_ID+0x1b0>)
 8008746:	430b      	orrs	r3, r1
 8008748:	6053      	str	r3, [r2, #4]
		break;
 800874a:	e07b      	b.n	8008844 <GPIO_u8SetPinD_ID+0x1a4>
			local_state = NOK;
 800874c:	2301      	movs	r3, #1
 800874e:	73fb      	strb	r3, [r7, #15]
		break;
 8008750:	e078      	b.n	8008844 <GPIO_u8SetPinD_ID+0x1a4>
	case GPIO_PORTB:
		if (local_pin <= GPIO_u8f_REG_LEN) {
 8008752:	7b7b      	ldrb	r3, [r7, #13]
 8008754:	2b07      	cmp	r3, #7
 8008756:	d817      	bhi.n	8008788 <GPIO_u8SetPinD_ID+0xe8>
			GPIO_B->GPIO_CRL &= ~((GPIO_u8CLR_MASK)
 8008758:	4b3e      	ldr	r3, [pc, #248]	; (8008854 <GPIO_u8SetPinD_ID+0x1b4>)
 800875a:	681b      	ldr	r3, [r3, #0]
					<< (local_pin * GPIO_u8PIN_REG_SIZE));
 800875c:	7b7a      	ldrb	r2, [r7, #13]
 800875e:	0092      	lsls	r2, r2, #2
 8008760:	210f      	movs	r1, #15
 8008762:	fa01 f202 	lsl.w	r2, r1, r2
			GPIO_B->GPIO_CRL &= ~((GPIO_u8CLR_MASK)
 8008766:	43d2      	mvns	r2, r2
 8008768:	4611      	mov	r1, r2
 800876a:	4a3a      	ldr	r2, [pc, #232]	; (8008854 <GPIO_u8SetPinD_ID+0x1b4>)
 800876c:	400b      	ands	r3, r1
 800876e:	6013      	str	r3, [r2, #0]
			GPIO_B->GPIO_CRL |= ((Copy_u8Mode)
 8008770:	4b38      	ldr	r3, [pc, #224]	; (8008854 <GPIO_u8SetPinD_ID+0x1b4>)
 8008772:	681b      	ldr	r3, [r3, #0]
					<< (local_pin * GPIO_u8PIN_REG_SIZE));
 8008774:	79b9      	ldrb	r1, [r7, #6]
 8008776:	7b7a      	ldrb	r2, [r7, #13]
 8008778:	0092      	lsls	r2, r2, #2
 800877a:	fa01 f202 	lsl.w	r2, r1, r2
 800877e:	4611      	mov	r1, r2
			GPIO_B->GPIO_CRL |= ((Copy_u8Mode)
 8008780:	4a34      	ldr	r2, [pc, #208]	; (8008854 <GPIO_u8SetPinD_ID+0x1b4>)
 8008782:	430b      	orrs	r3, r1
 8008784:	6013      	str	r3, [r2, #0]
			GPIO_B->GPIO_CRH |= ((Copy_u8Mode)
					<< ((local_pin - GPIO_u8OFSET) * GPIO_u8PIN_REG_SIZE));
		} else {
			local_state = NOK;
		}
		break;
 8008786:	e05d      	b.n	8008844 <GPIO_u8SetPinD_ID+0x1a4>
		} else if (local_pin <= GPIO_u8L_REG_LEN) {
 8008788:	7b7b      	ldrb	r3, [r7, #13]
 800878a:	2b0f      	cmp	r3, #15
 800878c:	d819      	bhi.n	80087c2 <GPIO_u8SetPinD_ID+0x122>
			GPIO_B->GPIO_CRH &= ~((GPIO_u8CLR_MASK)
 800878e:	4b31      	ldr	r3, [pc, #196]	; (8008854 <GPIO_u8SetPinD_ID+0x1b4>)
 8008790:	685b      	ldr	r3, [r3, #4]
					<< ((local_pin - GPIO_u8OFSET) * GPIO_u8PIN_REG_SIZE));
 8008792:	7b7a      	ldrb	r2, [r7, #13]
 8008794:	3a08      	subs	r2, #8
 8008796:	0092      	lsls	r2, r2, #2
 8008798:	210f      	movs	r1, #15
 800879a:	fa01 f202 	lsl.w	r2, r1, r2
			GPIO_B->GPIO_CRH &= ~((GPIO_u8CLR_MASK)
 800879e:	43d2      	mvns	r2, r2
 80087a0:	4611      	mov	r1, r2
 80087a2:	4a2c      	ldr	r2, [pc, #176]	; (8008854 <GPIO_u8SetPinD_ID+0x1b4>)
 80087a4:	400b      	ands	r3, r1
 80087a6:	6053      	str	r3, [r2, #4]
			GPIO_B->GPIO_CRH |= ((Copy_u8Mode)
 80087a8:	4b2a      	ldr	r3, [pc, #168]	; (8008854 <GPIO_u8SetPinD_ID+0x1b4>)
 80087aa:	685b      	ldr	r3, [r3, #4]
					<< ((local_pin - GPIO_u8OFSET) * GPIO_u8PIN_REG_SIZE));
 80087ac:	79b9      	ldrb	r1, [r7, #6]
 80087ae:	7b7a      	ldrb	r2, [r7, #13]
 80087b0:	3a08      	subs	r2, #8
 80087b2:	0092      	lsls	r2, r2, #2
 80087b4:	fa01 f202 	lsl.w	r2, r1, r2
 80087b8:	4611      	mov	r1, r2
			GPIO_B->GPIO_CRH |= ((Copy_u8Mode)
 80087ba:	4a26      	ldr	r2, [pc, #152]	; (8008854 <GPIO_u8SetPinD_ID+0x1b4>)
 80087bc:	430b      	orrs	r3, r1
 80087be:	6053      	str	r3, [r2, #4]
		break;
 80087c0:	e040      	b.n	8008844 <GPIO_u8SetPinD_ID+0x1a4>
			local_state = NOK;
 80087c2:	2301      	movs	r3, #1
 80087c4:	73fb      	strb	r3, [r7, #15]
		break;
 80087c6:	e03d      	b.n	8008844 <GPIO_u8SetPinD_ID+0x1a4>
	case GPIO_PORTC:
		if (local_pin <= GPIO_u8f_REG_LEN) {
 80087c8:	7b7b      	ldrb	r3, [r7, #13]
 80087ca:	2b07      	cmp	r3, #7
 80087cc:	d817      	bhi.n	80087fe <GPIO_u8SetPinD_ID+0x15e>
			GPIO_C->GPIO_CRL &= ~((GPIO_u8CLR_MASK)
 80087ce:	4b22      	ldr	r3, [pc, #136]	; (8008858 <GPIO_u8SetPinD_ID+0x1b8>)
 80087d0:	681b      	ldr	r3, [r3, #0]
					<< (local_pin * GPIO_u8PIN_REG_SIZE));
 80087d2:	7b7a      	ldrb	r2, [r7, #13]
 80087d4:	0092      	lsls	r2, r2, #2
 80087d6:	210f      	movs	r1, #15
 80087d8:	fa01 f202 	lsl.w	r2, r1, r2
			GPIO_C->GPIO_CRL &= ~((GPIO_u8CLR_MASK)
 80087dc:	43d2      	mvns	r2, r2
 80087de:	4611      	mov	r1, r2
 80087e0:	4a1d      	ldr	r2, [pc, #116]	; (8008858 <GPIO_u8SetPinD_ID+0x1b8>)
 80087e2:	400b      	ands	r3, r1
 80087e4:	6013      	str	r3, [r2, #0]
			GPIO_C->GPIO_CRL |= ((Copy_u8Mode)
 80087e6:	4b1c      	ldr	r3, [pc, #112]	; (8008858 <GPIO_u8SetPinD_ID+0x1b8>)
 80087e8:	681b      	ldr	r3, [r3, #0]
					<< (local_pin * GPIO_u8PIN_REG_SIZE));
 80087ea:	79b9      	ldrb	r1, [r7, #6]
 80087ec:	7b7a      	ldrb	r2, [r7, #13]
 80087ee:	0092      	lsls	r2, r2, #2
 80087f0:	fa01 f202 	lsl.w	r2, r1, r2
 80087f4:	4611      	mov	r1, r2
			GPIO_C->GPIO_CRL |= ((Copy_u8Mode)
 80087f6:	4a18      	ldr	r2, [pc, #96]	; (8008858 <GPIO_u8SetPinD_ID+0x1b8>)
 80087f8:	430b      	orrs	r3, r1
 80087fa:	6013      	str	r3, [r2, #0]
			GPIO_C->GPIO_CRH |= ((Copy_u8Mode)
					<< ((local_pin - GPIO_u8OFSET) * GPIO_u8PIN_REG_SIZE));
		} else {
			local_state = NOK;
		}
		break;
 80087fc:	e022      	b.n	8008844 <GPIO_u8SetPinD_ID+0x1a4>
		} else if (local_pin <= GPIO_u8L_REG_LEN) {
 80087fe:	7b7b      	ldrb	r3, [r7, #13]
 8008800:	2b0f      	cmp	r3, #15
 8008802:	d819      	bhi.n	8008838 <GPIO_u8SetPinD_ID+0x198>
			GPIO_C->GPIO_CRH &= ~((GPIO_u8CLR_MASK)
 8008804:	4b14      	ldr	r3, [pc, #80]	; (8008858 <GPIO_u8SetPinD_ID+0x1b8>)
 8008806:	685b      	ldr	r3, [r3, #4]
					<< ((local_pin - GPIO_u8OFSET) * GPIO_u8PIN_REG_SIZE));
 8008808:	7b7a      	ldrb	r2, [r7, #13]
 800880a:	3a08      	subs	r2, #8
 800880c:	0092      	lsls	r2, r2, #2
 800880e:	210f      	movs	r1, #15
 8008810:	fa01 f202 	lsl.w	r2, r1, r2
			GPIO_C->GPIO_CRH &= ~((GPIO_u8CLR_MASK)
 8008814:	43d2      	mvns	r2, r2
 8008816:	4611      	mov	r1, r2
 8008818:	4a0f      	ldr	r2, [pc, #60]	; (8008858 <GPIO_u8SetPinD_ID+0x1b8>)
 800881a:	400b      	ands	r3, r1
 800881c:	6053      	str	r3, [r2, #4]
			GPIO_C->GPIO_CRH |= ((Copy_u8Mode)
 800881e:	4b0e      	ldr	r3, [pc, #56]	; (8008858 <GPIO_u8SetPinD_ID+0x1b8>)
 8008820:	685b      	ldr	r3, [r3, #4]
					<< ((local_pin - GPIO_u8OFSET) * GPIO_u8PIN_REG_SIZE));
 8008822:	79b9      	ldrb	r1, [r7, #6]
 8008824:	7b7a      	ldrb	r2, [r7, #13]
 8008826:	3a08      	subs	r2, #8
 8008828:	0092      	lsls	r2, r2, #2
 800882a:	fa01 f202 	lsl.w	r2, r1, r2
 800882e:	4611      	mov	r1, r2
			GPIO_C->GPIO_CRH |= ((Copy_u8Mode)
 8008830:	4a09      	ldr	r2, [pc, #36]	; (8008858 <GPIO_u8SetPinD_ID+0x1b8>)
 8008832:	430b      	orrs	r3, r1
 8008834:	6053      	str	r3, [r2, #4]
		break;
 8008836:	e005      	b.n	8008844 <GPIO_u8SetPinD_ID+0x1a4>
			local_state = NOK;
 8008838:	2301      	movs	r3, #1
 800883a:	73fb      	strb	r3, [r7, #15]
		break;
 800883c:	e002      	b.n	8008844 <GPIO_u8SetPinD_ID+0x1a4>
	default:
		local_state = NOK;
 800883e:	2301      	movs	r3, #1
 8008840:	73fb      	strb	r3, [r7, #15]
		break;
 8008842:	bf00      	nop
	}

	return local_state;
 8008844:	7bfb      	ldrb	r3, [r7, #15]
}
 8008846:	4618      	mov	r0, r3
 8008848:	3714      	adds	r7, #20
 800884a:	46bd      	mov	sp, r7
 800884c:	bc80      	pop	{r7}
 800884e:	4770      	bx	lr
 8008850:	40010800 	.word	0x40010800
 8008854:	40010c00 	.word	0x40010c00
 8008858:	40011000 	.word	0x40011000

0800885c <GPIO_u8SetPinV_ID>:
Error_t GPIO_u8SetPinV_ID(GPIO_u8PIN_t Copy_u8PinId, u8 Copy_u8Value) {
 800885c:	b480      	push	{r7}
 800885e:	b085      	sub	sp, #20
 8008860:	af00      	add	r7, sp, #0
 8008862:	4603      	mov	r3, r0
 8008864:	460a      	mov	r2, r1
 8008866:	71fb      	strb	r3, [r7, #7]
 8008868:	4613      	mov	r3, r2
 800886a:	71bb      	strb	r3, [r7, #6]
	u8 local_port = (Copy_u8PinId / GPIO_u8R_PINS) + 1;
 800886c:	79fb      	ldrb	r3, [r7, #7]
 800886e:	091b      	lsrs	r3, r3, #4
 8008870:	b2db      	uxtb	r3, r3
 8008872:	3301      	adds	r3, #1
 8008874:	73bb      	strb	r3, [r7, #14]
	u8 local_pin = Copy_u8PinId % GPIO_u8R_PINS;
 8008876:	79fb      	ldrb	r3, [r7, #7]
 8008878:	f003 030f 	and.w	r3, r3, #15
 800887c:	737b      	strb	r3, [r7, #13]
	Error_t local_state = OK;
 800887e:	2300      	movs	r3, #0
 8008880:	73fb      	strb	r3, [r7, #15]
	switch (local_port) {
 8008882:	7bbb      	ldrb	r3, [r7, #14]
 8008884:	2b03      	cmp	r3, #3
 8008886:	d028      	beq.n	80088da <GPIO_u8SetPinV_ID+0x7e>
 8008888:	2b03      	cmp	r3, #3
 800888a:	dc37      	bgt.n	80088fc <GPIO_u8SetPinV_ID+0xa0>
 800888c:	2b01      	cmp	r3, #1
 800888e:	d002      	beq.n	8008896 <GPIO_u8SetPinV_ID+0x3a>
 8008890:	2b02      	cmp	r3, #2
 8008892:	d011      	beq.n	80088b8 <GPIO_u8SetPinV_ID+0x5c>
 8008894:	e032      	b.n	80088fc <GPIO_u8SetPinV_ID+0xa0>
	case GPIO_PORTA:
		WRITE_BIT(GPIO_A->GPIO_ODR, local_pin, Copy_u8Value);
 8008896:	4b1e      	ldr	r3, [pc, #120]	; (8008910 <GPIO_u8SetPinV_ID+0xb4>)
 8008898:	68db      	ldr	r3, [r3, #12]
 800889a:	7b7a      	ldrb	r2, [r7, #13]
 800889c:	2101      	movs	r1, #1
 800889e:	fa01 f202 	lsl.w	r2, r1, r2
 80088a2:	43d2      	mvns	r2, r2
 80088a4:	4013      	ands	r3, r2
 80088a6:	79b9      	ldrb	r1, [r7, #6]
 80088a8:	7b7a      	ldrb	r2, [r7, #13]
 80088aa:	fa01 f202 	lsl.w	r2, r1, r2
 80088ae:	4611      	mov	r1, r2
 80088b0:	4a17      	ldr	r2, [pc, #92]	; (8008910 <GPIO_u8SetPinV_ID+0xb4>)
 80088b2:	430b      	orrs	r3, r1
 80088b4:	60d3      	str	r3, [r2, #12]
		break;
 80088b6:	e024      	b.n	8008902 <GPIO_u8SetPinV_ID+0xa6>
	case GPIO_PORTB:
		WRITE_BIT(GPIO_B->GPIO_ODR, local_pin, Copy_u8Value);
 80088b8:	4b16      	ldr	r3, [pc, #88]	; (8008914 <GPIO_u8SetPinV_ID+0xb8>)
 80088ba:	68db      	ldr	r3, [r3, #12]
 80088bc:	7b7a      	ldrb	r2, [r7, #13]
 80088be:	2101      	movs	r1, #1
 80088c0:	fa01 f202 	lsl.w	r2, r1, r2
 80088c4:	43d2      	mvns	r2, r2
 80088c6:	4013      	ands	r3, r2
 80088c8:	79b9      	ldrb	r1, [r7, #6]
 80088ca:	7b7a      	ldrb	r2, [r7, #13]
 80088cc:	fa01 f202 	lsl.w	r2, r1, r2
 80088d0:	4611      	mov	r1, r2
 80088d2:	4a10      	ldr	r2, [pc, #64]	; (8008914 <GPIO_u8SetPinV_ID+0xb8>)
 80088d4:	430b      	orrs	r3, r1
 80088d6:	60d3      	str	r3, [r2, #12]
		break;
 80088d8:	e013      	b.n	8008902 <GPIO_u8SetPinV_ID+0xa6>
	case GPIO_PORTC:
		WRITE_BIT(GPIO_C->GPIO_ODR, local_pin, Copy_u8Value);
 80088da:	4b0f      	ldr	r3, [pc, #60]	; (8008918 <GPIO_u8SetPinV_ID+0xbc>)
 80088dc:	68db      	ldr	r3, [r3, #12]
 80088de:	7b7a      	ldrb	r2, [r7, #13]
 80088e0:	2101      	movs	r1, #1
 80088e2:	fa01 f202 	lsl.w	r2, r1, r2
 80088e6:	43d2      	mvns	r2, r2
 80088e8:	4013      	ands	r3, r2
 80088ea:	79b9      	ldrb	r1, [r7, #6]
 80088ec:	7b7a      	ldrb	r2, [r7, #13]
 80088ee:	fa01 f202 	lsl.w	r2, r1, r2
 80088f2:	4611      	mov	r1, r2
 80088f4:	4a08      	ldr	r2, [pc, #32]	; (8008918 <GPIO_u8SetPinV_ID+0xbc>)
 80088f6:	430b      	orrs	r3, r1
 80088f8:	60d3      	str	r3, [r2, #12]
		break;
 80088fa:	e002      	b.n	8008902 <GPIO_u8SetPinV_ID+0xa6>
	default:
		local_state = NOK;
 80088fc:	2301      	movs	r3, #1
 80088fe:	73fb      	strb	r3, [r7, #15]
		break;
 8008900:	bf00      	nop
	}

	return local_state;
 8008902:	7bfb      	ldrb	r3, [r7, #15]
}
 8008904:	4618      	mov	r0, r3
 8008906:	3714      	adds	r7, #20
 8008908:	46bd      	mov	sp, r7
 800890a:	bc80      	pop	{r7}
 800890c:	4770      	bx	lr
 800890e:	bf00      	nop
 8008910:	40010800 	.word	0x40010800
 8008914:	40010c00 	.word	0x40010c00
 8008918:	40011000 	.word	0x40011000

0800891c <NVIC_u8Set_EN_IRQ>:
	SCB->AIRCR = NVIC_PR_OPTIONS;

	return OK;
}

Error_t NVIC_u8Set_EN_IRQ(NVIC_Prority_t Copy_IRQ_ID) {
 800891c:	b480      	push	{r7}
 800891e:	b085      	sub	sp, #20
 8008920:	af00      	add	r7, sp, #0
 8008922:	4603      	mov	r3, r0
 8008924:	71fb      	strb	r3, [r7, #7]
	Error_t Copy_status = OK;
 8008926:	2300      	movs	r3, #0
 8008928:	73fb      	strb	r3, [r7, #15]
	u8 Copy_ID_Index = Copy_IRQ_ID / NVIC_REG_SIZE;
 800892a:	79fb      	ldrb	r3, [r7, #7]
 800892c:	095b      	lsrs	r3, r3, #5
 800892e:	73bb      	strb	r3, [r7, #14]
	if (Copy_IRQ_ID < INTERRUPT_TOTAL) {
 8008930:	79fb      	ldrb	r3, [r7, #7]
 8008932:	2b3b      	cmp	r3, #59	; 0x3b
 8008934:	d80c      	bhi.n	8008950 <NVIC_u8Set_EN_IRQ+0x34>
		Copy_IRQ_ID = Copy_IRQ_ID % NVIC_REG_SIZE;
 8008936:	79fb      	ldrb	r3, [r7, #7]
 8008938:	f003 031f 	and.w	r3, r3, #31
 800893c:	71fb      	strb	r3, [r7, #7]
		NVIC->NVIC_ISER[Copy_ID_Index] = 1 << Copy_IRQ_ID;
 800893e:	79fb      	ldrb	r3, [r7, #7]
 8008940:	2201      	movs	r2, #1
 8008942:	fa02 f103 	lsl.w	r1, r2, r3
 8008946:	4a06      	ldr	r2, [pc, #24]	; (8008960 <NVIC_u8Set_EN_IRQ+0x44>)
 8008948:	7bbb      	ldrb	r3, [r7, #14]
 800894a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 800894e:	e001      	b.n	8008954 <NVIC_u8Set_EN_IRQ+0x38>
	} else {
		Copy_status = NOK;
 8008950:	2301      	movs	r3, #1
 8008952:	73fb      	strb	r3, [r7, #15]
	}
	return Copy_status;
 8008954:	7bfb      	ldrb	r3, [r7, #15]
}
 8008956:	4618      	mov	r0, r3
 8008958:	3714      	adds	r7, #20
 800895a:	46bd      	mov	sp, r7
 800895c:	bc80      	pop	{r7}
 800895e:	4770      	bx	lr
 8008960:	e000e100 	.word	0xe000e100

08008964 <RCC_voidInitSystemClock>:
#include "RCC_Private.h"
#include "RCC_CONF.h"
#include "RCC_Interface.h"

void RCC_voidInitSystemClock(void)
{
 8008964:	b480      	push	{r7}
 8008966:	af00      	add	r7, sp, #0
#if RCC_u8CLK_TYPE==RCC_u8HSE_CRYSTAL
	RCC->RCC_CR=0x00010080;
 8008968:	4b03      	ldr	r3, [pc, #12]	; (8008978 <RCC_voidInitSystemClock+0x14>)
 800896a:	4a04      	ldr	r2, [pc, #16]	; (800897c <RCC_voidInitSystemClock+0x18>)
 800896c:	601a      	str	r2, [r3, #0]
	RCC->RCC_CR = 0x00010080;
#else
	#error("You choosed wrong Clock Type")
#endif

}
 800896e:	bf00      	nop
 8008970:	46bd      	mov	sp, r7
 8008972:	bc80      	pop	{r7}
 8008974:	4770      	bx	lr
 8008976:	bf00      	nop
 8008978:	40021000 	.word	0x40021000
 800897c:	00010080 	.word	0x00010080

08008980 <RCC_voidEnablePeriphralCLK>:

Error_t RCC_voidEnablePeriphralCLK(PeriphralBusId_t Copy_enPeriphralId)
{	
 8008980:	b480      	push	{r7}
 8008982:	b085      	sub	sp, #20
 8008984:	af00      	add	r7, sp, #0
 8008986:	4603      	mov	r3, r0
 8008988:	80fb      	strh	r3, [r7, #6]
	u8 Local_u8BusID =Copy_enPeriphralId/100;
 800898a:	88fb      	ldrh	r3, [r7, #6]
 800898c:	4a25      	ldr	r2, [pc, #148]	; (8008a24 <RCC_voidEnablePeriphralCLK+0xa4>)
 800898e:	fba2 2303 	umull	r2, r3, r2, r3
 8008992:	095b      	lsrs	r3, r3, #5
 8008994:	b29b      	uxth	r3, r3
 8008996:	73bb      	strb	r3, [r7, #14]
	u8 Local_u8PeriphralID =Copy_enPeriphralId % 100;
 8008998:	88fb      	ldrh	r3, [r7, #6]
 800899a:	4a22      	ldr	r2, [pc, #136]	; (8008a24 <RCC_voidEnablePeriphralCLK+0xa4>)
 800899c:	fba2 1203 	umull	r1, r2, r2, r3
 80089a0:	0952      	lsrs	r2, r2, #5
 80089a2:	2164      	movs	r1, #100	; 0x64
 80089a4:	fb01 f202 	mul.w	r2, r1, r2
 80089a8:	1a9b      	subs	r3, r3, r2
 80089aa:	b29b      	uxth	r3, r3
 80089ac:	737b      	strb	r3, [r7, #13]

	Error_t Local_enErrorState=OK;
 80089ae:	2300      	movs	r3, #0
 80089b0:	73fb      	strb	r3, [r7, #15]

	if(Local_u8PeriphralID  <= 31) //unsigned
 80089b2:	7b7b      	ldrb	r3, [r7, #13]
 80089b4:	2b1f      	cmp	r3, #31
 80089b6:	d82d      	bhi.n	8008a14 <RCC_voidEnablePeriphralCLK+0x94>
	{
		switch(Local_u8BusID)
 80089b8:	7bbb      	ldrb	r3, [r7, #14]
 80089ba:	2b03      	cmp	r3, #3
 80089bc:	d01c      	beq.n	80089f8 <RCC_voidEnablePeriphralCLK+0x78>
 80089be:	2b03      	cmp	r3, #3
 80089c0:	dc25      	bgt.n	8008a0e <RCC_voidEnablePeriphralCLK+0x8e>
 80089c2:	2b01      	cmp	r3, #1
 80089c4:	d002      	beq.n	80089cc <RCC_voidEnablePeriphralCLK+0x4c>
 80089c6:	2b02      	cmp	r3, #2
 80089c8:	d00b      	beq.n	80089e2 <RCC_voidEnablePeriphralCLK+0x62>
 80089ca:	e020      	b.n	8008a0e <RCC_voidEnablePeriphralCLK+0x8e>
		{
		case RCC_u8AHB: SET_BIT(RCC->RCC_AHBENR,Local_u8PeriphralID) ;    	
 80089cc:	4b16      	ldr	r3, [pc, #88]	; (8008a28 <RCC_voidEnablePeriphralCLK+0xa8>)
 80089ce:	695b      	ldr	r3, [r3, #20]
 80089d0:	7b7a      	ldrb	r2, [r7, #13]
 80089d2:	2101      	movs	r1, #1
 80089d4:	fa01 f202 	lsl.w	r2, r1, r2
 80089d8:	4611      	mov	r1, r2
 80089da:	4a13      	ldr	r2, [pc, #76]	; (8008a28 <RCC_voidEnablePeriphralCLK+0xa8>)
 80089dc:	430b      	orrs	r3, r1
 80089de:	6153      	str	r3, [r2, #20]
			break;
 80089e0:	e01a      	b.n	8008a18 <RCC_voidEnablePeriphralCLK+0x98>

		case RCC_u8APB2:SET_BIT(RCC->RCC_APB2ENR,Local_u8PeriphralID) ;	
 80089e2:	4b11      	ldr	r3, [pc, #68]	; (8008a28 <RCC_voidEnablePeriphralCLK+0xa8>)
 80089e4:	699b      	ldr	r3, [r3, #24]
 80089e6:	7b7a      	ldrb	r2, [r7, #13]
 80089e8:	2101      	movs	r1, #1
 80089ea:	fa01 f202 	lsl.w	r2, r1, r2
 80089ee:	4611      	mov	r1, r2
 80089f0:	4a0d      	ldr	r2, [pc, #52]	; (8008a28 <RCC_voidEnablePeriphralCLK+0xa8>)
 80089f2:	430b      	orrs	r3, r1
 80089f4:	6193      	str	r3, [r2, #24]
			break;
 80089f6:	e00f      	b.n	8008a18 <RCC_voidEnablePeriphralCLK+0x98>

		case RCC_u8APB1: SET_BIT(RCC->RCC_APB1ENR,Local_u8PeriphralID) ;	
 80089f8:	4b0b      	ldr	r3, [pc, #44]	; (8008a28 <RCC_voidEnablePeriphralCLK+0xa8>)
 80089fa:	69db      	ldr	r3, [r3, #28]
 80089fc:	7b7a      	ldrb	r2, [r7, #13]
 80089fe:	2101      	movs	r1, #1
 8008a00:	fa01 f202 	lsl.w	r2, r1, r2
 8008a04:	4611      	mov	r1, r2
 8008a06:	4a08      	ldr	r2, [pc, #32]	; (8008a28 <RCC_voidEnablePeriphralCLK+0xa8>)
 8008a08:	430b      	orrs	r3, r1
 8008a0a:	61d3      	str	r3, [r2, #28]
			break;
 8008a0c:	e004      	b.n	8008a18 <RCC_voidEnablePeriphralCLK+0x98>
			
			
			
		default:
			Local_enErrorState=NOK;
 8008a0e:	2301      	movs	r3, #1
 8008a10:	73fb      	strb	r3, [r7, #15]
			break;
 8008a12:	e001      	b.n	8008a18 <RCC_voidEnablePeriphralCLK+0x98>
		}

	}
	else
	{
		Local_enErrorState=NOK;
 8008a14:	2301      	movs	r3, #1
 8008a16:	73fb      	strb	r3, [r7, #15]

	}

	return Local_enErrorState;
 8008a18:	7bfb      	ldrb	r3, [r7, #15]
}
 8008a1a:	4618      	mov	r0, r3
 8008a1c:	3714      	adds	r7, #20
 8008a1e:	46bd      	mov	sp, r7
 8008a20:	bc80      	pop	{r7}
 8008a22:	4770      	bx	lr
 8008a24:	51eb851f 	.word	0x51eb851f
 8008a28:	40021000 	.word	0x40021000

08008a2c <SoftwareReset>:

#include "Reset.h"

#define NVICKEY 0x05FA0004
// Function to perform a software reset
void SoftwareReset(void) {
 8008a2c:	b580      	push	{r7, lr}
 8008a2e:	af00      	add	r7, sp, #0

	STK_u8StopTimer();
 8008a30:	f000 f940 	bl	8008cb4 <STK_u8StopTimer>
	// Trigger a system reset by writing the key and reset request bit to AIRCR
	SCB->AIRCR = NVICKEY;
 8008a34:	4b01      	ldr	r3, [pc, #4]	; (8008a3c <SoftwareReset+0x10>)
 8008a36:	4a02      	ldr	r2, [pc, #8]	; (8008a40 <SoftwareReset+0x14>)
 8008a38:	60da      	str	r2, [r3, #12]

	// Wait for the reset to take effect
	while (1)
 8008a3a:	e7fe      	b.n	8008a3a <SoftwareReset+0xe>
 8008a3c:	e000ed00 	.word	0xe000ed00
 8008a40:	05fa0004 	.word	0x05fa0004

08008a44 <Send_voidCarUpdate>:
 * */

void Update_voidConfirm(u8 *ptr_u8readData) {
	GPIO_u8GetPinV_ID(PB_CHECK, ptr_u8readData);
}
void Send_voidCarUpdate() {
 8008a44:	b580      	push	{r7, lr}
 8008a46:	b082      	sub	sp, #8
 8008a48:	af00      	add	r7, sp, #0

	for (u8 index = 0; index < OPTIONS_SIZE; index++) {
 8008a4a:	2300      	movs	r3, #0
 8008a4c:	71fb      	strb	r3, [r7, #7]
 8008a4e:	e00d      	b.n	8008a6c <Send_voidCarUpdate+0x28>
		if (Global_u8CarUpdate[index] != 0) {
 8008a50:	79fb      	ldrb	r3, [r7, #7]
 8008a52:	4a0a      	ldr	r2, [pc, #40]	; (8008a7c <Send_voidCarUpdate+0x38>)
 8008a54:	5cd3      	ldrb	r3, [r2, r3]
 8008a56:	2b00      	cmp	r3, #0
 8008a58:	d005      	beq.n	8008a66 <Send_voidCarUpdate+0x22>
			UART2_u8SendByteBusyw8(Global_u8CarUpdate[index]);
 8008a5a:	79fb      	ldrb	r3, [r7, #7]
 8008a5c:	4a07      	ldr	r2, [pc, #28]	; (8008a7c <Send_voidCarUpdate+0x38>)
 8008a5e:	5cd3      	ldrb	r3, [r2, r3]
 8008a60:	4618      	mov	r0, r3
 8008a62:	f000 fa77 	bl	8008f54 <UART2_u8SendByteBusyw8>
	for (u8 index = 0; index < OPTIONS_SIZE; index++) {
 8008a66:	79fb      	ldrb	r3, [r7, #7]
 8008a68:	3301      	adds	r3, #1
 8008a6a:	71fb      	strb	r3, [r7, #7]
 8008a6c:	79fb      	ldrb	r3, [r7, #7]
 8008a6e:	2b0e      	cmp	r3, #14
 8008a70:	d9ee      	bls.n	8008a50 <Send_voidCarUpdate+0xc>
		} else {

			//do nothing
		}
	}
}
 8008a72:	bf00      	nop
 8008a74:	bf00      	nop
 8008a76:	3708      	adds	r7, #8
 8008a78:	46bd      	mov	sp, r7
 8008a7a:	bd80      	pop	{r7, pc}
 8008a7c:	20000000 	.word	0x20000000

08008a80 <SendFrameRequest>:
		} else {
			//do nothing
		}
	}
}
void SendFrameRequest() {
 8008a80:	b580      	push	{r7, lr}
 8008a82:	af00      	add	r7, sp, #0
	UART1_u8SendStringBusyW8("ERR_1_MOTOR_SPEED_V_2");
 8008a84:	4802      	ldr	r0, [pc, #8]	; (8008a90 <SendFrameRequest+0x10>)
 8008a86:	f000 f9b1 	bl	8008dec <UART1_u8SendStringBusyW8>
}
 8008a8a:	bf00      	nop
 8008a8c:	bd80      	pop	{r7, pc}
 8008a8e:	bf00      	nop
 8008a90:	08009310 	.word	0x08009310

08008a94 <SendFrameRequest2>:
void SendFrameRequest2() {
 8008a94:	b580      	push	{r7, lr}
 8008a96:	af00      	add	r7, sp, #0
	UART1_u8SendStringBusyW8("ERR_1_FAN_V_2");
 8008a98:	4802      	ldr	r0, [pc, #8]	; (8008aa4 <SendFrameRequest2+0x10>)
 8008a9a:	f000 f9a7 	bl	8008dec <UART1_u8SendStringBusyW8>
}
 8008a9e:	bf00      	nop
 8008aa0:	bd80      	pop	{r7, pc}
 8008aa2:	bf00      	nop
 8008aa4:	08009328 	.word	0x08009328

08008aa8 <Check_voidGotoReset>:
void Check_voidGotoReset() {
 8008aa8:	b480      	push	{r7}
 8008aaa:	af00      	add	r7, sp, #0
	if (UPDATEreadData == TRUE && PBreadData == TRUE) {
 8008aac:	4b0c      	ldr	r3, [pc, #48]	; (8008ae0 <Check_voidGotoReset+0x38>)
 8008aae:	781b      	ldrb	r3, [r3, #0]
 8008ab0:	2b80      	cmp	r3, #128	; 0x80
 8008ab2:	d106      	bne.n	8008ac2 <Check_voidGotoReset+0x1a>
 8008ab4:	4b0b      	ldr	r3, [pc, #44]	; (8008ae4 <Check_voidGotoReset+0x3c>)
 8008ab6:	781b      	ldrb	r3, [r3, #0]
 8008ab8:	2b80      	cmp	r3, #128	; 0x80
 8008aba:	d102      	bne.n	8008ac2 <Check_voidGotoReset+0x1a>
		Global_enuAppStates = APP_REQ_Update;
 8008abc:	4b0a      	ldr	r3, [pc, #40]	; (8008ae8 <Check_voidGotoReset+0x40>)
 8008abe:	2201      	movs	r2, #1
 8008ac0:	701a      	strb	r2, [r3, #0]
	} else {
		// do nothing
	}

	if (UPDATEreadData == TRUE && ERRreadData == TRUE) {
 8008ac2:	4b07      	ldr	r3, [pc, #28]	; (8008ae0 <Check_voidGotoReset+0x38>)
 8008ac4:	781b      	ldrb	r3, [r3, #0]
 8008ac6:	2b80      	cmp	r3, #128	; 0x80
 8008ac8:	d106      	bne.n	8008ad8 <Check_voidGotoReset+0x30>
 8008aca:	4b08      	ldr	r3, [pc, #32]	; (8008aec <Check_voidGotoReset+0x44>)
 8008acc:	781b      	ldrb	r3, [r3, #0]
 8008ace:	2b80      	cmp	r3, #128	; 0x80
 8008ad0:	d102      	bne.n	8008ad8 <Check_voidGotoReset+0x30>
		Global_enuAppStates = APP_REQ_Update;
 8008ad2:	4b05      	ldr	r3, [pc, #20]	; (8008ae8 <Check_voidGotoReset+0x40>)
 8008ad4:	2201      	movs	r2, #1
 8008ad6:	701a      	strb	r2, [r3, #0]
	} else {
		// do nothing
	}

}
 8008ad8:	bf00      	nop
 8008ada:	46bd      	mov	sp, r7
 8008adc:	bc80      	pop	{r7}
 8008ade:	4770      	bx	lr
 8008ae0:	20000010 	.word	0x20000010
 8008ae4:	2000000f 	.word	0x2000000f
 8008ae8:	20000070 	.word	0x20000070
 8008aec:	20000011 	.word	0x20000011

08008af0 <EXIT_FUN>:

void EXIT_FUN() {
 8008af0:	b480      	push	{r7}
 8008af2:	af00      	add	r7, sp, #0
	PBreadData = TRUE;
 8008af4:	4b03      	ldr	r3, [pc, #12]	; (8008b04 <EXIT_FUN+0x14>)
 8008af6:	2280      	movs	r2, #128	; 0x80
 8008af8:	701a      	strb	r2, [r3, #0]

}
 8008afa:	bf00      	nop
 8008afc:	46bd      	mov	sp, r7
 8008afe:	bc80      	pop	{r7}
 8008b00:	4770      	bx	lr
 8008b02:	bf00      	nop
 8008b04:	2000000f 	.word	0x2000000f

08008b08 <main>:
int main(void) {
 8008b08:	b580      	push	{r7, lr}
 8008b0a:	af00      	add	r7, sp, #0

	RCC_voidInitSystemClock();
 8008b0c:	f7ff ff2a 	bl	8008964 <RCC_voidInitSystemClock>
	RCC_voidEnablePeriphralCLK(APB2_IOPAEN);
 8008b10:	20ca      	movs	r0, #202	; 0xca
 8008b12:	f7ff ff35 	bl	8008980 <RCC_voidEnablePeriphralCLK>
	RCC_voidEnablePeriphralCLK(APB2_IOPBEN);
 8008b16:	20cb      	movs	r0, #203	; 0xcb
 8008b18:	f7ff ff32 	bl	8008980 <RCC_voidEnablePeriphralCLK>
	RCC_voidEnablePeriphralCLK(APB2_IOPCEN);
 8008b1c:	20cc      	movs	r0, #204	; 0xcc
 8008b1e:	f7ff ff2f 	bl	8008980 <RCC_voidEnablePeriphralCLK>

	GPIO_u8Init();
 8008b22:	f7ff fd9d 	bl	8008660 <GPIO_u8Init>
	Uart_Service_voidInit();
 8008b26:	f000 fa91 	bl	800904c <Uart_Service_voidInit>
	GPIO_u8SetPinV_ID(Pin_B1, LOW);
 8008b2a:	2100      	movs	r1, #0
 8008b2c:	2011      	movs	r0, #17
 8008b2e:	f7ff fe95 	bl	800885c <GPIO_u8SetPinV_ID>
	GPIO_u8SetPinV_ID(Pin_A4, LOW);
 8008b32:	2100      	movs	r1, #0
 8008b34:	2004      	movs	r0, #4
 8008b36:	f7ff fe91 	bl	800885c <GPIO_u8SetPinV_ID>
// exint
	// input bullup
	GPIO_u8SetPinV_ID(PB_CHECK, HIGH);
 8008b3a:	2101      	movs	r1, #1
 8008b3c:	2000      	movs	r0, #0
 8008b3e:	f7ff fe8d 	bl	800885c <GPIO_u8SetPinV_ID>

	NVIC_u8Set_EN_IRQ(INTERRUPT_EXTI0);
 8008b42:	2006      	movs	r0, #6
 8008b44:	f7ff feea 	bl	800891c <NVIC_u8Set_EN_IRQ>
	EXTI_u8Set_Inturrupt_latch(EXTI_Line0, EXTI_FAILING);
 8008b48:	2100      	movs	r1, #0
 8008b4a:	2000      	movs	r0, #0
 8008b4c:	f7ff fb72 	bl	8008234 <EXTI_u8Set_Inturrupt_latch>
	EXTI_u8Setter_IRQ(EXTI_Line0, EXIT_FUN);
 8008b50:	4934      	ldr	r1, [pc, #208]	; (8008c24 <main+0x11c>)
 8008b52:	2000      	movs	r0, #0
 8008b54:	f7ff fb0c 	bl	8008170 <EXTI_u8Setter_IRQ>
	EXTI_u8En(EXTI_Line0);
 8008b58:	2000      	movs	r0, #0
 8008b5a:	f7ff fb2b 	bl	80081b4 <EXTI_u8En>

	STK_u8Init();
 8008b5e:	f000 f899 	bl	8008c94 <STK_u8Init>
	//STK_u8ENInterrupt();
	//STK_u8SetIntervalPeriodic(1000000, function);
	Send_voidCarUpdate();
 8008b62:	f7ff ff6f 	bl	8008a44 <Send_voidCarUpdate>
	while (1) {
//UART1_u8SendStringBusyW8("APP2");
#if 1

		switch (Global_enuAppStates) {
 8008b66:	4b30      	ldr	r3, [pc, #192]	; (8008c28 <main+0x120>)
 8008b68:	781b      	ldrb	r3, [r3, #0]
 8008b6a:	2b05      	cmp	r3, #5
 8008b6c:	d858      	bhi.n	8008c20 <main+0x118>
 8008b6e:	a201      	add	r2, pc, #4	; (adr r2, 8008b74 <main+0x6c>)
 8008b70:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008b74:	08008b8d 	.word	0x08008b8d
 8008b78:	08008c07 	.word	0x08008c07
 8008b7c:	08008bbb 	.word	0x08008bbb
 8008b80:	08008bcd 	.word	0x08008bcd
 8008b84:	08008bdf 	.word	0x08008bdf
 8008b88:	08008bfb 	.word	0x08008bfb
		case APP_normal:
			App_HandelFlames();
 8008b8c:	f000 faae 	bl	80090ec <App_HandelFlames>
			App_HandelFlames2();
 8008b90:	f000 fae8 	bl	8009164 <App_HandelFlames2>
			Check_voidGotoReset();
 8008b94:	f7ff ff88 	bl	8008aa8 <Check_voidGotoReset>
			//	STK_u8SetBusyWait(1000);

			static u8 data = 1;
			GPIO_u8SetPinV_ID(Pin_A6, data);
 8008b98:	4b24      	ldr	r3, [pc, #144]	; (8008c2c <main+0x124>)
 8008b9a:	781b      	ldrb	r3, [r3, #0]
 8008b9c:	4619      	mov	r1, r3
 8008b9e:	2006      	movs	r0, #6
 8008ba0:	f7ff fe5c 	bl	800885c <GPIO_u8SetPinV_ID>
			data = !data;
 8008ba4:	4b21      	ldr	r3, [pc, #132]	; (8008c2c <main+0x124>)
 8008ba6:	781b      	ldrb	r3, [r3, #0]
 8008ba8:	2b00      	cmp	r3, #0
 8008baa:	bf0c      	ite	eq
 8008bac:	2301      	moveq	r3, #1
 8008bae:	2300      	movne	r3, #0
 8008bb0:	b2db      	uxtb	r3, r3
 8008bb2:	461a      	mov	r2, r3
 8008bb4:	4b1d      	ldr	r3, [pc, #116]	; (8008c2c <main+0x124>)
 8008bb6:	701a      	strb	r2, [r3, #0]
			break;
 8008bb8:	e033      	b.n	8008c22 <main+0x11a>

		case APP_REPORT_ERR1:
			SendFrameRequest();
 8008bba:	f7ff ff61 	bl	8008a80 <SendFrameRequest>
			ERRreadData = TRUE;
 8008bbe:	4b1c      	ldr	r3, [pc, #112]	; (8008c30 <main+0x128>)
 8008bc0:	2280      	movs	r2, #128	; 0x80
 8008bc2:	701a      	strb	r2, [r3, #0]
			Global_enuAppStates = APP_normal;
 8008bc4:	4b18      	ldr	r3, [pc, #96]	; (8008c28 <main+0x120>)
 8008bc6:	2200      	movs	r2, #0
 8008bc8:	701a      	strb	r2, [r3, #0]

			break;
 8008bca:	e02a      	b.n	8008c22 <main+0x11a>
		case APP_REPORT_ERR2:
			SendFrameRequest2();
 8008bcc:	f7ff ff62 	bl	8008a94 <SendFrameRequest2>
			ERRreadData = TRUE;
 8008bd0:	4b17      	ldr	r3, [pc, #92]	; (8008c30 <main+0x128>)
 8008bd2:	2280      	movs	r2, #128	; 0x80
 8008bd4:	701a      	strb	r2, [r3, #0]
			Global_enuAppStates = APP_normal;
 8008bd6:	4b14      	ldr	r3, [pc, #80]	; (8008c28 <main+0x120>)
 8008bd8:	2200      	movs	r2, #0
 8008bda:	701a      	strb	r2, [r3, #0]

			break;
 8008bdc:	e021      	b.n	8008c22 <main+0x11a>

		case APP_normal_CHECKPB:
			UPDATEreadData = TRUE;
 8008bde:	4b15      	ldr	r3, [pc, #84]	; (8008c34 <main+0x12c>)
 8008be0:	2280      	movs	r2, #128	; 0x80
 8008be2:	701a      	strb	r2, [r3, #0]
			PBreadData = FALSE;
 8008be4:	4b14      	ldr	r3, [pc, #80]	; (8008c38 <main+0x130>)
 8008be6:	2255      	movs	r2, #85	; 0x55
 8008be8:	701a      	strb	r2, [r3, #0]
			GPIO_u8SetPinV_ID(Pin_A4, HIGH);
 8008bea:	2101      	movs	r1, #1
 8008bec:	2004      	movs	r0, #4
 8008bee:	f7ff fe35 	bl	800885c <GPIO_u8SetPinV_ID>
			Global_enuAppStates = APP_normal;
 8008bf2:	4b0d      	ldr	r3, [pc, #52]	; (8008c28 <main+0x120>)
 8008bf4:	2200      	movs	r2, #0
 8008bf6:	701a      	strb	r2, [r3, #0]
			break;
 8008bf8:	e013      	b.n	8008c22 <main+0x11a>
		case APP_REPORT_CONF:
			Send_voidCarUpdate();
 8008bfa:	f7ff ff23 	bl	8008a44 <Send_voidCarUpdate>
			Global_enuAppStates = APP_normal;
 8008bfe:	4b0a      	ldr	r3, [pc, #40]	; (8008c28 <main+0x120>)
 8008c00:	2200      	movs	r2, #0
 8008c02:	701a      	strb	r2, [r3, #0]
			break;
 8008c04:	e00d      	b.n	8008c22 <main+0x11a>

		case APP_REQ_Update:
			//UART1_u8SendStringBusyW8("Update RES \n");

			// check on boot marker
			if (*(u16*) BOOT_DDRESSMARK != BOOT_FLASHMARK) {
 8008c06:	4b0d      	ldr	r3, [pc, #52]	; (8008c3c <main+0x134>)
 8008c08:	881b      	ldrh	r3, [r3, #0]
 8008c0a:	f64a 2255 	movw	r2, #43605	; 0xaa55
 8008c0e:	4293      	cmp	r3, r2
 8008c10:	d004      	beq.n	8008c1c <main+0x114>
				FLASH_enWriteData(BOOT_DDRESSMARK, BOOT_FLASHMARK);
 8008c12:	f64a 2155 	movw	r1, #43605	; 0xaa55
 8008c16:	4809      	ldr	r0, [pc, #36]	; (8008c3c <main+0x134>)
 8008c18:	f7ff fc90 	bl	800853c <FLASH_enWriteData>
			} else {
				//do nothimg
			}

			SoftwareReset();
 8008c1c:	f7ff ff06 	bl	8008a2c <SoftwareReset>
		default:
			break;
 8008c20:	bf00      	nop
		switch (Global_enuAppStates) {
 8008c22:	e7a0      	b.n	8008b66 <main+0x5e>
 8008c24:	08008af1 	.word	0x08008af1
 8008c28:	20000070 	.word	0x20000070
 8008c2c:	20000012 	.word	0x20000012
 8008c30:	20000011 	.word	0x20000011
 8008c34:	20000010 	.word	0x20000010
 8008c38:	2000000f 	.word	0x2000000f
 8008c3c:	0800f000 	.word	0x0800f000

08008c40 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8008c40:	480d      	ldr	r0, [pc, #52]	; (8008c78 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8008c42:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 8008c44:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8008c48:	480c      	ldr	r0, [pc, #48]	; (8008c7c <LoopForever+0x6>)
  ldr r1, =_edata
 8008c4a:	490d      	ldr	r1, [pc, #52]	; (8008c80 <LoopForever+0xa>)
  ldr r2, =_sidata
 8008c4c:	4a0d      	ldr	r2, [pc, #52]	; (8008c84 <LoopForever+0xe>)
  movs r3, #0
 8008c4e:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8008c50:	e002      	b.n	8008c58 <LoopCopyDataInit>

08008c52 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8008c52:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8008c54:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8008c56:	3304      	adds	r3, #4

08008c58 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8008c58:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8008c5a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8008c5c:	d3f9      	bcc.n	8008c52 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8008c5e:	4a0a      	ldr	r2, [pc, #40]	; (8008c88 <LoopForever+0x12>)
  ldr r4, =_ebss
 8008c60:	4c0a      	ldr	r4, [pc, #40]	; (8008c8c <LoopForever+0x16>)
  movs r3, #0
 8008c62:	2300      	movs	r3, #0
  b LoopFillZerobss
 8008c64:	e001      	b.n	8008c6a <LoopFillZerobss>

08008c66 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8008c66:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8008c68:	3204      	adds	r2, #4

08008c6a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8008c6a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8008c6c:	d3fb      	bcc.n	8008c66 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 8008c6e:	f000 fb1f 	bl	80092b0 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8008c72:	f7ff ff49 	bl	8008b08 <main>

08008c76 <LoopForever>:

LoopForever:
  b LoopForever
 8008c76:	e7fe      	b.n	8008c76 <LoopForever>
  ldr   r0, =_estack
 8008c78:	20005000 	.word	0x20005000
  ldr r0, =_sdata
 8008c7c:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8008c80:	20000014 	.word	0x20000014
  ldr r2, =_sidata
 8008c84:	080093c0 	.word	0x080093c0
  ldr r2, =_sbss
 8008c88:	20000014 	.word	0x20000014
  ldr r4, =_ebss
 8008c8c:	20000154 	.word	0x20000154

08008c90 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8008c90:	e7fe      	b.n	8008c90 <ADC1_2_IRQHandler>
	...

08008c94 <STK_u8Init>:
#include"SYSTICK_Interface.h"

static void (*STK_PtrCallBack)(void) = {NULLPTR };
static u8 STK_CHAECK_PERODIC = 0;
static u8 STK_ProtectionFlage = 0;
Error_t STK_u8Init() {
 8008c94:	b480      	push	{r7}
 8008c96:	af00      	add	r7, sp, #0

// Enable ISR
#if STK_SOURCE == STK_u8AHB
	SET_BIT(SYSTICK->STK_CTRL ,2);
	#elif STK_SOURCE == STK_u8AHB_8
	CLR_BIT(SYSTICK->STK_CTRL, 2);
 8008c98:	4b05      	ldr	r3, [pc, #20]	; (8008cb0 <STK_u8Init+0x1c>)
 8008c9a:	681b      	ldr	r3, [r3, #0]
 8008c9c:	4a04      	ldr	r2, [pc, #16]	; (8008cb0 <STK_u8Init+0x1c>)
 8008c9e:	f023 0304 	bic.w	r3, r3, #4
 8008ca2:	6013      	str	r3, [r2, #0]
     #warning"define STK_SOURCE "
	#endif 
	// enable STK
	//SET_BIT(SYSTICK->STK_CTRL, 0);
	// Enable CR source
	return OK;
 8008ca4:	2300      	movs	r3, #0
}
 8008ca6:	4618      	mov	r0, r3
 8008ca8:	46bd      	mov	sp, r7
 8008caa:	bc80      	pop	{r7}
 8008cac:	4770      	bx	lr
 8008cae:	bf00      	nop
 8008cb0:	e000e010 	.word	0xe000e010

08008cb4 <STK_u8StopTimer>:
	}

	// return
	return local_u8status;
}
Error_t STK_u8StopTimer() {
 8008cb4:	b580      	push	{r7, lr}
 8008cb6:	b082      	sub	sp, #8
 8008cb8:	af00      	add	r7, sp, #0
	// set loud and value with zeroxs
	Error_t local_u8status = OK;
 8008cba:	2300      	movs	r3, #0
 8008cbc:	71fb      	strb	r3, [r7, #7]

	CLR_BIT(SYSTICK->STK_CTRL, 0);
 8008cbe:	4b09      	ldr	r3, [pc, #36]	; (8008ce4 <STK_u8StopTimer+0x30>)
 8008cc0:	681b      	ldr	r3, [r3, #0]
 8008cc2:	4a08      	ldr	r2, [pc, #32]	; (8008ce4 <STK_u8StopTimer+0x30>)
 8008cc4:	f023 0301 	bic.w	r3, r3, #1
 8008cc8:	6013      	str	r3, [r2, #0]
	SYSTICK->STK_LOAD = 0;
 8008cca:	4b06      	ldr	r3, [pc, #24]	; (8008ce4 <STK_u8StopTimer+0x30>)
 8008ccc:	2200      	movs	r2, #0
 8008cce:	605a      	str	r2, [r3, #4]
	SYSTICK->STK_VAL  = 0;
 8008cd0:	4b04      	ldr	r3, [pc, #16]	; (8008ce4 <STK_u8StopTimer+0x30>)
 8008cd2:	2200      	movs	r2, #0
 8008cd4:	609a      	str	r2, [r3, #8]
	STK_u8DSInterrupt();
 8008cd6:	f000 f807 	bl	8008ce8 <STK_u8DSInterrupt>

	return local_u8status;
 8008cda:	79fb      	ldrb	r3, [r7, #7]
}
 8008cdc:	4618      	mov	r0, r3
 8008cde:	3708      	adds	r7, #8
 8008ce0:	46bd      	mov	sp, r7
 8008ce2:	bd80      	pop	{r7, pc}
 8008ce4:	e000e010 	.word	0xe000e010

08008ce8 <STK_u8DSInterrupt>:
Error_t STK_u8ENInterrupt() {
	SET_BIT(SYSTICK->STK_CTRL, 1);
	return OK;

}
Error_t STK_u8DSInterrupt() {
 8008ce8:	b480      	push	{r7}
 8008cea:	af00      	add	r7, sp, #0
	CLR_BIT(SYSTICK->STK_CTRL, 1);
 8008cec:	4b05      	ldr	r3, [pc, #20]	; (8008d04 <STK_u8DSInterrupt+0x1c>)
 8008cee:	681b      	ldr	r3, [r3, #0]
 8008cf0:	4a04      	ldr	r2, [pc, #16]	; (8008d04 <STK_u8DSInterrupt+0x1c>)
 8008cf2:	f023 0302 	bic.w	r3, r3, #2
 8008cf6:	6013      	str	r3, [r2, #0]
	return OK;
 8008cf8:	2300      	movs	r3, #0
}
 8008cfa:	4618      	mov	r0, r3
 8008cfc:	46bd      	mov	sp, r7
 8008cfe:	bc80      	pop	{r7}
 8008d00:	4770      	bx	lr
 8008d02:	bf00      	nop
 8008d04:	e000e010 	.word	0xe000e010

08008d08 <SysTick_Handler>:
	} else {
		local_u8status = NOK;
	}
	return local_u8status;
}
void SysTick_Handler() {
 8008d08:	b580      	push	{r7, lr}
 8008d0a:	af00      	add	r7, sp, #0

	if (STK_CHAECK_PERODIC == 1) {
 8008d0c:	4b08      	ldr	r3, [pc, #32]	; (8008d30 <SysTick_Handler+0x28>)
 8008d0e:	781b      	ldrb	r3, [r3, #0]
 8008d10:	2b01      	cmp	r3, #1
 8008d12:	d107      	bne.n	8008d24 <SysTick_Handler+0x1c>
		STK_u8StopTimer();
 8008d14:	f7ff ffce 	bl	8008cb4 <STK_u8StopTimer>
		STK_CHAECK_PERODIC = 0;
 8008d18:	4b05      	ldr	r3, [pc, #20]	; (8008d30 <SysTick_Handler+0x28>)
 8008d1a:	2200      	movs	r2, #0
 8008d1c:	701a      	strb	r2, [r3, #0]
		STK_ProtectionFlage = 0;
 8008d1e:	4b05      	ldr	r3, [pc, #20]	; (8008d34 <SysTick_Handler+0x2c>)
 8008d20:	2200      	movs	r2, #0
 8008d22:	701a      	strb	r2, [r3, #0]
	} else {
		// do nothing
	}
	STK_PtrCallBack();
 8008d24:	4b04      	ldr	r3, [pc, #16]	; (8008d38 <SysTick_Handler+0x30>)
 8008d26:	681b      	ldr	r3, [r3, #0]
 8008d28:	4798      	blx	r3

}
 8008d2a:	bf00      	nop
 8008d2c:	bd80      	pop	{r7, pc}
 8008d2e:	bf00      	nop
 8008d30:	20000078 	.word	0x20000078
 8008d34:	20000079 	.word	0x20000079
 8008d38:	20000074 	.word	0x20000074

08008d3c <UART1_voidInit>:
/*
 void (*UART1_CallBack[UART_CALLBACK_SIZE])(void) =
 {	NULLPTR, NULLPTR,NULLPTR,NULLPTR };
 */

void UART1_voidInit() {
 8008d3c:	b480      	push	{r7}
 8008d3e:	af00      	add	r7, sp, #0

	/******** baud rate **********/
	UART1->USART_BRR = BAUDRATE;
 8008d40:	4b19      	ldr	r3, [pc, #100]	; (8008da8 <UART1_voidInit+0x6c>)
 8008d42:	2245      	movs	r2, #69	; 0x45
 8008d44:	609a      	str	r2, [r3, #8]

	/******** frame format *******/
//no parity
	CLR_BIT(UART1->USART_CR1, PCE);
 8008d46:	4b18      	ldr	r3, [pc, #96]	; (8008da8 <UART1_voidInit+0x6c>)
 8008d48:	68db      	ldr	r3, [r3, #12]
 8008d4a:	4a17      	ldr	r2, [pc, #92]	; (8008da8 <UART1_voidInit+0x6c>)
 8008d4c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8008d50:	60d3      	str	r3, [r2, #12]
// 1 start 8bit data n stop
	CLR_BIT(UART1->USART_CR1, M);
 8008d52:	4b15      	ldr	r3, [pc, #84]	; (8008da8 <UART1_voidInit+0x6c>)
 8008d54:	68db      	ldr	r3, [r3, #12]
 8008d56:	4a14      	ldr	r2, [pc, #80]	; (8008da8 <UART1_voidInit+0x6c>)
 8008d58:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8008d5c:	60d3      	str	r3, [r2, #12]
// 1 stop bit
	CLR_BIT(UART1->USART_CR2, StOP_0);
 8008d5e:	4b12      	ldr	r3, [pc, #72]	; (8008da8 <UART1_voidInit+0x6c>)
 8008d60:	691b      	ldr	r3, [r3, #16]
 8008d62:	4a11      	ldr	r2, [pc, #68]	; (8008da8 <UART1_voidInit+0x6c>)
 8008d64:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8008d68:	6113      	str	r3, [r2, #16]
	CLR_BIT(UART1->USART_CR2, StOP_1);
 8008d6a:	4b0f      	ldr	r3, [pc, #60]	; (8008da8 <UART1_voidInit+0x6c>)
 8008d6c:	691b      	ldr	r3, [r3, #16]
 8008d6e:	4a0e      	ldr	r2, [pc, #56]	; (8008da8 <UART1_voidInit+0x6c>)
 8008d70:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8008d74:	6113      	str	r3, [r2, #16]

	/******** enable RX **********/
	SET_BIT(UART1->USART_CR1, RE);
 8008d76:	4b0c      	ldr	r3, [pc, #48]	; (8008da8 <UART1_voidInit+0x6c>)
 8008d78:	68db      	ldr	r3, [r3, #12]
 8008d7a:	4a0b      	ldr	r2, [pc, #44]	; (8008da8 <UART1_voidInit+0x6c>)
 8008d7c:	f043 0304 	orr.w	r3, r3, #4
 8008d80:	60d3      	str	r3, [r2, #12]
	/******** enable TX **********/
	SET_BIT(UART1->USART_CR1, TE);
 8008d82:	4b09      	ldr	r3, [pc, #36]	; (8008da8 <UART1_voidInit+0x6c>)
 8008d84:	68db      	ldr	r3, [r3, #12]
 8008d86:	4a08      	ldr	r2, [pc, #32]	; (8008da8 <UART1_voidInit+0x6c>)
 8008d88:	f043 0308 	orr.w	r3, r3, #8
 8008d8c:	60d3      	str	r3, [r2, #12]
	/*********UART enable ********/
	SET_BIT(UART1->USART_CR1, UE);
 8008d8e:	4b06      	ldr	r3, [pc, #24]	; (8008da8 <UART1_voidInit+0x6c>)
 8008d90:	68db      	ldr	r3, [r3, #12]
 8008d92:	4a05      	ldr	r2, [pc, #20]	; (8008da8 <UART1_voidInit+0x6c>)
 8008d94:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8008d98:	60d3      	str	r3, [r2, #12]
	// clr status reg
	UART1->USART_SR = 0;
 8008d9a:	4b03      	ldr	r3, [pc, #12]	; (8008da8 <UART1_voidInit+0x6c>)
 8008d9c:	2200      	movs	r2, #0
 8008d9e:	601a      	str	r2, [r3, #0]
}
 8008da0:	bf00      	nop
 8008da2:	46bd      	mov	sp, r7
 8008da4:	bc80      	pop	{r7}
 8008da6:	4770      	bx	lr
 8008da8:	40013800 	.word	0x40013800

08008dac <UART1_u8SendByteBusyw8>:

Error_t UART1_u8SendByteBusyw8(u8 data) {
 8008dac:	b480      	push	{r7}
 8008dae:	b085      	sub	sp, #20
 8008db0:	af00      	add	r7, sp, #0
 8008db2:	4603      	mov	r3, r0
 8008db4:	71fb      	strb	r3, [r7, #7]
	Error_t local_u8Status = OK;
 8008db6:	2300      	movs	r3, #0
 8008db8:	73fb      	strb	r3, [r7, #15]
	while (!READ_BIT(UART1->USART_SR, TXE))
 8008dba:	bf00      	nop
 8008dbc:	4b0a      	ldr	r3, [pc, #40]	; (8008de8 <UART1_u8SendByteBusyw8+0x3c>)
 8008dbe:	681b      	ldr	r3, [r3, #0]
 8008dc0:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8008dc4:	2b00      	cmp	r3, #0
 8008dc6:	d0f9      	beq.n	8008dbc <UART1_u8SendByteBusyw8+0x10>
		; // txe ---- time out is needed
	UART1->USART_DR = data;
 8008dc8:	4a07      	ldr	r2, [pc, #28]	; (8008de8 <UART1_u8SendByteBusyw8+0x3c>)
 8008dca:	79fb      	ldrb	r3, [r7, #7]
 8008dcc:	6053      	str	r3, [r2, #4]
	CLR_BIT(UART1->USART_SR, TXE);
 8008dce:	4b06      	ldr	r3, [pc, #24]	; (8008de8 <UART1_u8SendByteBusyw8+0x3c>)
 8008dd0:	681b      	ldr	r3, [r3, #0]
 8008dd2:	4a05      	ldr	r2, [pc, #20]	; (8008de8 <UART1_u8SendByteBusyw8+0x3c>)
 8008dd4:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8008dd8:	6013      	str	r3, [r2, #0]
	return local_u8Status;
 8008dda:	7bfb      	ldrb	r3, [r7, #15]
}
 8008ddc:	4618      	mov	r0, r3
 8008dde:	3714      	adds	r7, #20
 8008de0:	46bd      	mov	sp, r7
 8008de2:	bc80      	pop	{r7}
 8008de4:	4770      	bx	lr
 8008de6:	bf00      	nop
 8008de8:	40013800 	.word	0x40013800

08008dec <UART1_u8SendStringBusyW8>:
	*data = UART1->USART_DR;
	CLR_BIT(UART1->USART_SR, RXNE);
	return local_u8Status;
}

Error_t UART1_u8SendStringBusyW8(char *data) {
 8008dec:	b580      	push	{r7, lr}
 8008dee:	b084      	sub	sp, #16
 8008df0:	af00      	add	r7, sp, #0
 8008df2:	6078      	str	r0, [r7, #4]
	Error_t local_u8Status = OK;
 8008df4:	2300      	movs	r3, #0
 8008df6:	73bb      	strb	r3, [r7, #14]

	for (u8 local_index = 0; data[local_index]; local_index++) {
 8008df8:	2300      	movs	r3, #0
 8008dfa:	73fb      	strb	r3, [r7, #15]
 8008dfc:	e009      	b.n	8008e12 <UART1_u8SendStringBusyW8+0x26>
		UART1_u8SendByteBusyw8(data[local_index]);
 8008dfe:	7bfb      	ldrb	r3, [r7, #15]
 8008e00:	687a      	ldr	r2, [r7, #4]
 8008e02:	4413      	add	r3, r2
 8008e04:	781b      	ldrb	r3, [r3, #0]
 8008e06:	4618      	mov	r0, r3
 8008e08:	f7ff ffd0 	bl	8008dac <UART1_u8SendByteBusyw8>
	for (u8 local_index = 0; data[local_index]; local_index++) {
 8008e0c:	7bfb      	ldrb	r3, [r7, #15]
 8008e0e:	3301      	adds	r3, #1
 8008e10:	73fb      	strb	r3, [r7, #15]
 8008e12:	7bfb      	ldrb	r3, [r7, #15]
 8008e14:	687a      	ldr	r2, [r7, #4]
 8008e16:	4413      	add	r3, r2
 8008e18:	781b      	ldrb	r3, [r3, #0]
 8008e1a:	2b00      	cmp	r3, #0
 8008e1c:	d1ef      	bne.n	8008dfe <UART1_u8SendStringBusyW8+0x12>
	}
	return local_u8Status;
 8008e1e:	7bbb      	ldrb	r3, [r7, #14]
}
 8008e20:	4618      	mov	r0, r3
 8008e22:	3710      	adds	r7, #16
 8008e24:	46bd      	mov	sp, r7
 8008e26:	bd80      	pop	{r7, pc}

08008e28 <UART1_u8RecieveByte>:

	return local_u8Status;

}

Error_t UART1_u8RecieveByte(volatile u8 *data) {
 8008e28:	b480      	push	{r7}
 8008e2a:	b085      	sub	sp, #20
 8008e2c:	af00      	add	r7, sp, #0
 8008e2e:	6078      	str	r0, [r7, #4]
	Error_t local_u8Status = OK;
 8008e30:	2300      	movs	r3, #0
 8008e32:	73fb      	strb	r3, [r7, #15]
// return DR reg
	*data = UART1->USART_DR;
 8008e34:	4b05      	ldr	r3, [pc, #20]	; (8008e4c <UART1_u8RecieveByte+0x24>)
 8008e36:	685b      	ldr	r3, [r3, #4]
 8008e38:	b2da      	uxtb	r2, r3
 8008e3a:	687b      	ldr	r3, [r7, #4]
 8008e3c:	701a      	strb	r2, [r3, #0]
	return local_u8Status;
 8008e3e:	7bfb      	ldrb	r3, [r7, #15]

}
 8008e40:	4618      	mov	r0, r3
 8008e42:	3714      	adds	r7, #20
 8008e44:	46bd      	mov	sp, r7
 8008e46:	bc80      	pop	{r7}
 8008e48:	4770      	bx	lr
 8008e4a:	bf00      	nop
 8008e4c:	40013800 	.word	0x40013800

08008e50 <UART1_u8EnterruptEnRX>:
	UART1_MUNRX = 0;
	UART1_DataReady = 0;
}

Error_t UART1_u8RecieveStringBusyW8(u8 *data);
Error_t UART1_u8EnterruptEnRX(void) {
 8008e50:	b480      	push	{r7}
 8008e52:	b083      	sub	sp, #12
 8008e54:	af00      	add	r7, sp, #0
	Error_t local_u8Status = OK;
 8008e56:	2300      	movs	r3, #0
 8008e58:	71fb      	strb	r3, [r7, #7]
	SET_BIT(UART1->USART_CR1, RXNEIE);
 8008e5a:	4b06      	ldr	r3, [pc, #24]	; (8008e74 <UART1_u8EnterruptEnRX+0x24>)
 8008e5c:	68db      	ldr	r3, [r3, #12]
 8008e5e:	4a05      	ldr	r2, [pc, #20]	; (8008e74 <UART1_u8EnterruptEnRX+0x24>)
 8008e60:	f043 0320 	orr.w	r3, r3, #32
 8008e64:	60d3      	str	r3, [r2, #12]
	return local_u8Status;
 8008e66:	79fb      	ldrb	r3, [r7, #7]
}
 8008e68:	4618      	mov	r0, r3
 8008e6a:	370c      	adds	r7, #12
 8008e6c:	46bd      	mov	sp, r7
 8008e6e:	bc80      	pop	{r7}
 8008e70:	4770      	bx	lr
 8008e72:	bf00      	nop
 8008e74:	40013800 	.word	0x40013800

08008e78 <UART1_u8EnterruptCallBackRX>:
Error_t UART1_u8EnterruptDsRX(void) {
	Error_t local_u8Status = OK;
	CLR_BIT(UART1->USART_CR1, RXNEIE);
	return local_u8Status;
}
Error_t UART1_u8EnterruptCallBackRX(void (*Rx)(void)) {
 8008e78:	b480      	push	{r7}
 8008e7a:	b085      	sub	sp, #20
 8008e7c:	af00      	add	r7, sp, #0
 8008e7e:	6078      	str	r0, [r7, #4]
	Error_t local_u8Status = OK;
 8008e80:	2300      	movs	r3, #0
 8008e82:	73fb      	strb	r3, [r7, #15]
	if (Rx != NULLPTR) {
 8008e84:	687b      	ldr	r3, [r7, #4]
 8008e86:	2b00      	cmp	r3, #0
 8008e88:	d003      	beq.n	8008e92 <UART1_u8EnterruptCallBackRX+0x1a>
		GlobalRX = Rx;
 8008e8a:	4a06      	ldr	r2, [pc, #24]	; (8008ea4 <UART1_u8EnterruptCallBackRX+0x2c>)
 8008e8c:	687b      	ldr	r3, [r7, #4]
 8008e8e:	6013      	str	r3, [r2, #0]
 8008e90:	e001      	b.n	8008e96 <UART1_u8EnterruptCallBackRX+0x1e>
	} else {
		local_u8Status = NULL_PTR;
 8008e92:	2303      	movs	r3, #3
 8008e94:	73fb      	strb	r3, [r7, #15]
	}
	return local_u8Status;
 8008e96:	7bfb      	ldrb	r3, [r7, #15]
}
 8008e98:	4618      	mov	r0, r3
 8008e9a:	3714      	adds	r7, #20
 8008e9c:	46bd      	mov	sp, r7
 8008e9e:	bc80      	pop	{r7}
 8008ea0:	4770      	bx	lr
 8008ea2:	bf00      	nop
 8008ea4:	2000007c 	.word	0x2000007c

08008ea8 <USART1_IRQHandler>:
	Error_t local_u8Status = OK;

	return local_u8Status;
}

void USART1_IRQHandler(void) {
 8008ea8:	b580      	push	{r7, lr}
 8008eaa:	af00      	add	r7, sp, #0
	 } else {
	 // do nothing
	 }
	 }
	 */
	if (READ_BIT(UART1->USART_SR, RXNE)) {
 8008eac:	4b0a      	ldr	r3, [pc, #40]	; (8008ed8 <USART1_IRQHandler+0x30>)
 8008eae:	681b      	ldr	r3, [r3, #0]
 8008eb0:	f003 0320 	and.w	r3, r3, #32
 8008eb4:	2b00      	cmp	r3, #0
 8008eb6:	d00c      	beq.n	8008ed2 <USART1_IRQHandler+0x2a>
		if (GlobalRX) {
 8008eb8:	4b08      	ldr	r3, [pc, #32]	; (8008edc <USART1_IRQHandler+0x34>)
 8008eba:	681b      	ldr	r3, [r3, #0]
 8008ebc:	2b00      	cmp	r3, #0
 8008ebe:	d002      	beq.n	8008ec6 <USART1_IRQHandler+0x1e>
			GlobalRX();
 8008ec0:	4b06      	ldr	r3, [pc, #24]	; (8008edc <USART1_IRQHandler+0x34>)
 8008ec2:	681b      	ldr	r3, [r3, #0]
 8008ec4:	4798      	blx	r3

		}
		CLR_BIT(UART1->USART_SR, RXNE);
 8008ec6:	4b04      	ldr	r3, [pc, #16]	; (8008ed8 <USART1_IRQHandler+0x30>)
 8008ec8:	681b      	ldr	r3, [r3, #0]
 8008eca:	4a03      	ldr	r2, [pc, #12]	; (8008ed8 <USART1_IRQHandler+0x30>)
 8008ecc:	f023 0320 	bic.w	r3, r3, #32
 8008ed0:	6013      	str	r3, [r2, #0]

	}

}
 8008ed2:	bf00      	nop
 8008ed4:	bd80      	pop	{r7, pc}
 8008ed6:	bf00      	nop
 8008ed8:	40013800 	.word	0x40013800
 8008edc:	2000007c 	.word	0x2000007c

08008ee0 <UART2_voidInit>:
/*
 void (*UART2_CallBack[UART_CALLBACK_SIZE])(void) =
 {	NULLPTR, NULLPTR,NULLPTR,NULLPTR };
 */

void UART2_voidInit() {
 8008ee0:	b480      	push	{r7}
 8008ee2:	af00      	add	r7, sp, #0

	/******** baud rate **********/
	UART2->USART_BRR = BAUDRATE2;
 8008ee4:	4b1a      	ldr	r3, [pc, #104]	; (8008f50 <UART2_voidInit+0x70>)
 8008ee6:	f240 3241 	movw	r2, #833	; 0x341
 8008eea:	609a      	str	r2, [r3, #8]

	/******** frame format *******/
//no parity
	CLR_BIT(UART2->USART_CR1, PCE);
 8008eec:	4b18      	ldr	r3, [pc, #96]	; (8008f50 <UART2_voidInit+0x70>)
 8008eee:	68db      	ldr	r3, [r3, #12]
 8008ef0:	4a17      	ldr	r2, [pc, #92]	; (8008f50 <UART2_voidInit+0x70>)
 8008ef2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8008ef6:	60d3      	str	r3, [r2, #12]
// 1 start 8bit data n stop
	CLR_BIT(UART2->USART_CR1, M);
 8008ef8:	4b15      	ldr	r3, [pc, #84]	; (8008f50 <UART2_voidInit+0x70>)
 8008efa:	68db      	ldr	r3, [r3, #12]
 8008efc:	4a14      	ldr	r2, [pc, #80]	; (8008f50 <UART2_voidInit+0x70>)
 8008efe:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8008f02:	60d3      	str	r3, [r2, #12]
// 1 stop bit
	CLR_BIT(UART2->USART_CR2, StOP_0);
 8008f04:	4b12      	ldr	r3, [pc, #72]	; (8008f50 <UART2_voidInit+0x70>)
 8008f06:	691b      	ldr	r3, [r3, #16]
 8008f08:	4a11      	ldr	r2, [pc, #68]	; (8008f50 <UART2_voidInit+0x70>)
 8008f0a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8008f0e:	6113      	str	r3, [r2, #16]
	CLR_BIT(UART2->USART_CR2, StOP_1);
 8008f10:	4b0f      	ldr	r3, [pc, #60]	; (8008f50 <UART2_voidInit+0x70>)
 8008f12:	691b      	ldr	r3, [r3, #16]
 8008f14:	4a0e      	ldr	r2, [pc, #56]	; (8008f50 <UART2_voidInit+0x70>)
 8008f16:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8008f1a:	6113      	str	r3, [r2, #16]

	/******** enable RX **********/
	SET_BIT(UART2->USART_CR1, RE);
 8008f1c:	4b0c      	ldr	r3, [pc, #48]	; (8008f50 <UART2_voidInit+0x70>)
 8008f1e:	68db      	ldr	r3, [r3, #12]
 8008f20:	4a0b      	ldr	r2, [pc, #44]	; (8008f50 <UART2_voidInit+0x70>)
 8008f22:	f043 0304 	orr.w	r3, r3, #4
 8008f26:	60d3      	str	r3, [r2, #12]
	/******** enable TX **********/
	SET_BIT(UART2->USART_CR1, TE);
 8008f28:	4b09      	ldr	r3, [pc, #36]	; (8008f50 <UART2_voidInit+0x70>)
 8008f2a:	68db      	ldr	r3, [r3, #12]
 8008f2c:	4a08      	ldr	r2, [pc, #32]	; (8008f50 <UART2_voidInit+0x70>)
 8008f2e:	f043 0308 	orr.w	r3, r3, #8
 8008f32:	60d3      	str	r3, [r2, #12]
	/*********UART enable ********/
	SET_BIT(UART2->USART_CR1, UE);
 8008f34:	4b06      	ldr	r3, [pc, #24]	; (8008f50 <UART2_voidInit+0x70>)
 8008f36:	68db      	ldr	r3, [r3, #12]
 8008f38:	4a05      	ldr	r2, [pc, #20]	; (8008f50 <UART2_voidInit+0x70>)
 8008f3a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8008f3e:	60d3      	str	r3, [r2, #12]
	// clr status reg
	UART2->USART_SR = 0;
 8008f40:	4b03      	ldr	r3, [pc, #12]	; (8008f50 <UART2_voidInit+0x70>)
 8008f42:	2200      	movs	r2, #0
 8008f44:	601a      	str	r2, [r3, #0]
}
 8008f46:	bf00      	nop
 8008f48:	46bd      	mov	sp, r7
 8008f4a:	bc80      	pop	{r7}
 8008f4c:	4770      	bx	lr
 8008f4e:	bf00      	nop
 8008f50:	40004400 	.word	0x40004400

08008f54 <UART2_u8SendByteBusyw8>:

Error_t UART2_u8SendByteBusyw8(u8 data) {
 8008f54:	b480      	push	{r7}
 8008f56:	b085      	sub	sp, #20
 8008f58:	af00      	add	r7, sp, #0
 8008f5a:	4603      	mov	r3, r0
 8008f5c:	71fb      	strb	r3, [r7, #7]
	Error_t local_u8Status = OK;
 8008f5e:	2300      	movs	r3, #0
 8008f60:	73fb      	strb	r3, [r7, #15]
	while (!READ_BIT(UART2->USART_SR, TXE))
 8008f62:	bf00      	nop
 8008f64:	4b0a      	ldr	r3, [pc, #40]	; (8008f90 <UART2_u8SendByteBusyw8+0x3c>)
 8008f66:	681b      	ldr	r3, [r3, #0]
 8008f68:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8008f6c:	2b00      	cmp	r3, #0
 8008f6e:	d0f9      	beq.n	8008f64 <UART2_u8SendByteBusyw8+0x10>
		; // txe ---- time out is needed
	UART2->USART_DR = data;
 8008f70:	4a07      	ldr	r2, [pc, #28]	; (8008f90 <UART2_u8SendByteBusyw8+0x3c>)
 8008f72:	79fb      	ldrb	r3, [r7, #7]
 8008f74:	6053      	str	r3, [r2, #4]
	CLR_BIT(UART2->USART_SR, TXE);
 8008f76:	4b06      	ldr	r3, [pc, #24]	; (8008f90 <UART2_u8SendByteBusyw8+0x3c>)
 8008f78:	681b      	ldr	r3, [r3, #0]
 8008f7a:	4a05      	ldr	r2, [pc, #20]	; (8008f90 <UART2_u8SendByteBusyw8+0x3c>)
 8008f7c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8008f80:	6013      	str	r3, [r2, #0]
	return local_u8Status;
 8008f82:	7bfb      	ldrb	r3, [r7, #15]
}
 8008f84:	4618      	mov	r0, r3
 8008f86:	3714      	adds	r7, #20
 8008f88:	46bd      	mov	sp, r7
 8008f8a:	bc80      	pop	{r7}
 8008f8c:	4770      	bx	lr
 8008f8e:	bf00      	nop
 8008f90:	40004400 	.word	0x40004400

08008f94 <UART2_u8RecieveByte>:

	return local_u8Status;

}

Error_t UART2_u8RecieveByte(volatile u8 *data) {
 8008f94:	b480      	push	{r7}
 8008f96:	b085      	sub	sp, #20
 8008f98:	af00      	add	r7, sp, #0
 8008f9a:	6078      	str	r0, [r7, #4]
	Error_t local_u8Status = OK;
 8008f9c:	2300      	movs	r3, #0
 8008f9e:	73fb      	strb	r3, [r7, #15]
// return DR reg
	*data = UART2->USART_DR;
 8008fa0:	4b05      	ldr	r3, [pc, #20]	; (8008fb8 <UART2_u8RecieveByte+0x24>)
 8008fa2:	685b      	ldr	r3, [r3, #4]
 8008fa4:	b2da      	uxtb	r2, r3
 8008fa6:	687b      	ldr	r3, [r7, #4]
 8008fa8:	701a      	strb	r2, [r3, #0]
	return local_u8Status;
 8008faa:	7bfb      	ldrb	r3, [r7, #15]

}
 8008fac:	4618      	mov	r0, r3
 8008fae:	3714      	adds	r7, #20
 8008fb0:	46bd      	mov	sp, r7
 8008fb2:	bc80      	pop	{r7}
 8008fb4:	4770      	bx	lr
 8008fb6:	bf00      	nop
 8008fb8:	40004400 	.word	0x40004400

08008fbc <UART2_u8EnterruptEnRX>:




Error_t UART2_u8RecieveStringBusyW8(u8 *data);
Error_t UART2_u8EnterruptEnRX(void) {
 8008fbc:	b480      	push	{r7}
 8008fbe:	b083      	sub	sp, #12
 8008fc0:	af00      	add	r7, sp, #0
	Error_t local_u8Status = OK;
 8008fc2:	2300      	movs	r3, #0
 8008fc4:	71fb      	strb	r3, [r7, #7]
	SET_BIT(UART2->USART_CR1, RXNEIE);
 8008fc6:	4b06      	ldr	r3, [pc, #24]	; (8008fe0 <UART2_u8EnterruptEnRX+0x24>)
 8008fc8:	68db      	ldr	r3, [r3, #12]
 8008fca:	4a05      	ldr	r2, [pc, #20]	; (8008fe0 <UART2_u8EnterruptEnRX+0x24>)
 8008fcc:	f043 0320 	orr.w	r3, r3, #32
 8008fd0:	60d3      	str	r3, [r2, #12]
	return local_u8Status;
 8008fd2:	79fb      	ldrb	r3, [r7, #7]
}
 8008fd4:	4618      	mov	r0, r3
 8008fd6:	370c      	adds	r7, #12
 8008fd8:	46bd      	mov	sp, r7
 8008fda:	bc80      	pop	{r7}
 8008fdc:	4770      	bx	lr
 8008fde:	bf00      	nop
 8008fe0:	40004400 	.word	0x40004400

08008fe4 <UART2_u8EnterruptCallBackRX>:
Error_t UART2_u8EnterruptDsRX(void) {
	Error_t local_u8Status = OK;
	CLR_BIT(UART2->USART_CR1, RXNEIE);
	return local_u8Status;
}
Error_t UART2_u8EnterruptCallBackRX(void (*Rx)(void)) {
 8008fe4:	b480      	push	{r7}
 8008fe6:	b085      	sub	sp, #20
 8008fe8:	af00      	add	r7, sp, #0
 8008fea:	6078      	str	r0, [r7, #4]
	Error_t local_u8Status = OK;
 8008fec:	2300      	movs	r3, #0
 8008fee:	73fb      	strb	r3, [r7, #15]
	if (Rx != NULLPTR) {
 8008ff0:	687b      	ldr	r3, [r7, #4]
 8008ff2:	2b00      	cmp	r3, #0
 8008ff4:	d003      	beq.n	8008ffe <UART2_u8EnterruptCallBackRX+0x1a>
		GlobalRX_UART2 = Rx;
 8008ff6:	4a06      	ldr	r2, [pc, #24]	; (8009010 <UART2_u8EnterruptCallBackRX+0x2c>)
 8008ff8:	687b      	ldr	r3, [r7, #4]
 8008ffa:	6013      	str	r3, [r2, #0]
 8008ffc:	e001      	b.n	8009002 <UART2_u8EnterruptCallBackRX+0x1e>
	} else {
		local_u8Status = NULL_PTR;
 8008ffe:	2303      	movs	r3, #3
 8009000:	73fb      	strb	r3, [r7, #15]
	}
	return local_u8Status;
 8009002:	7bfb      	ldrb	r3, [r7, #15]
}
 8009004:	4618      	mov	r0, r3
 8009006:	3714      	adds	r7, #20
 8009008:	46bd      	mov	sp, r7
 800900a:	bc80      	pop	{r7}
 800900c:	4770      	bx	lr
 800900e:	bf00      	nop
 8009010:	20000080 	.word	0x20000080

08009014 <USART2_IRQHandler>:
	Error_t local_u8Status = OK;

	return local_u8Status;
}

void USART2_IRQHandler(void) {
 8009014:	b580      	push	{r7, lr}
 8009016:	af00      	add	r7, sp, #0
	 } else {
	 // do nothing
	 }
	 }
	 */
	if (READ_BIT(UART2->USART_SR, RXNE)) {
 8009018:	4b0a      	ldr	r3, [pc, #40]	; (8009044 <USART2_IRQHandler+0x30>)
 800901a:	681b      	ldr	r3, [r3, #0]
 800901c:	f003 0320 	and.w	r3, r3, #32
 8009020:	2b00      	cmp	r3, #0
 8009022:	d00c      	beq.n	800903e <USART2_IRQHandler+0x2a>
		if (GlobalRX_UART2) {
 8009024:	4b08      	ldr	r3, [pc, #32]	; (8009048 <USART2_IRQHandler+0x34>)
 8009026:	681b      	ldr	r3, [r3, #0]
 8009028:	2b00      	cmp	r3, #0
 800902a:	d002      	beq.n	8009032 <USART2_IRQHandler+0x1e>
			GlobalRX_UART2();
 800902c:	4b06      	ldr	r3, [pc, #24]	; (8009048 <USART2_IRQHandler+0x34>)
 800902e:	681b      	ldr	r3, [r3, #0]
 8009030:	4798      	blx	r3

		}
		CLR_BIT(UART2->USART_SR, RXNE);
 8009032:	4b04      	ldr	r3, [pc, #16]	; (8009044 <USART2_IRQHandler+0x30>)
 8009034:	681b      	ldr	r3, [r3, #0]
 8009036:	4a03      	ldr	r2, [pc, #12]	; (8009044 <USART2_IRQHandler+0x30>)
 8009038:	f023 0320 	bic.w	r3, r3, #32
 800903c:	6013      	str	r3, [r2, #0]

	}

}
 800903e:	bf00      	nop
 8009040:	bd80      	pop	{r7, pc}
 8009042:	bf00      	nop
 8009044:	40004400 	.word	0x40004400
 8009048:	20000080 	.word	0x20000080

0800904c <Uart_Service_voidInit>:
char Global_u8ArryReciveDirectUart2[BUFFERSIZE] = { 0 };
u8 Global_u8StackPointerArryRecive2 = 0;
volatile u8 dataReciev2 = 0;
/*****************************************************************************************************************/

void Uart_Service_voidInit() {
 800904c:	b580      	push	{r7, lr}
 800904e:	af00      	add	r7, sp, #0

	/***********************************uart1************************************************/
	RCC_voidEnablePeriphralCLK(APB2_USART1EN);
 8009050:	20d6      	movs	r0, #214	; 0xd6
 8009052:	f7ff fc95 	bl	8008980 <RCC_voidEnablePeriphralCLK>
	UART1_voidInit(); // init uart 9600
 8009056:	f7ff fe71 	bl	8008d3c <UART1_voidInit>
	NVIC_u8Set_EN_IRQ(INTERRUPT_USART1);
 800905a:	2025      	movs	r0, #37	; 0x25
 800905c:	f7ff fc5e 	bl	800891c <NVIC_u8Set_EN_IRQ>
	UART1_u8EnterruptCallBackRX(&UartFunction);
 8009060:	480a      	ldr	r0, [pc, #40]	; (800908c <Uart_Service_voidInit+0x40>)
 8009062:	f7ff ff09 	bl	8008e78 <UART1_u8EnterruptCallBackRX>
	UART1_u8EnterruptEnRX();
 8009066:	f7ff fef3 	bl	8008e50 <UART1_u8EnterruptEnRX>
	/***********************************************************************************/

	/************************************uart2***********************************************/

	RCC_voidEnablePeriphralCLK(APB1_USART2EN);
 800906a:	f240 103d 	movw	r0, #317	; 0x13d
 800906e:	f7ff fc87 	bl	8008980 <RCC_voidEnablePeriphralCLK>
	UART2_voidInit(); // init uart 115200
 8009072:	f7ff ff35 	bl	8008ee0 <UART2_voidInit>
	NVIC_u8Set_EN_IRQ(INTERRUPT_USART2);
 8009076:	2026      	movs	r0, #38	; 0x26
 8009078:	f7ff fc50 	bl	800891c <NVIC_u8Set_EN_IRQ>
	UART2_u8EnterruptCallBackRX(&Uart2Function);
 800907c:	4804      	ldr	r0, [pc, #16]	; (8009090 <Uart_Service_voidInit+0x44>)
 800907e:	f7ff ffb1 	bl	8008fe4 <UART2_u8EnterruptCallBackRX>
	UART2_u8EnterruptEnRX();
 8009082:	f7ff ff9b 	bl	8008fbc <UART2_u8EnterruptEnRX>
	/***********************************************************************************/

}
 8009086:	bf00      	nop
 8009088:	bd80      	pop	{r7, pc}
 800908a:	bf00      	nop
 800908c:	08009211 	.word	0x08009211
 8009090:	08009265 	.word	0x08009265

08009094 <StringCom>:
Bool_t StringCom(const char *ptr_SourceSTring, const char *ptr_CopySTring) {
 8009094:	b480      	push	{r7}
 8009096:	b085      	sub	sp, #20
 8009098:	af00      	add	r7, sp, #0
 800909a:	6078      	str	r0, [r7, #4]
 800909c:	6039      	str	r1, [r7, #0]
	Bool_t ReturnValue = TRUE;
 800909e:	2301      	movs	r3, #1
 80090a0:	73fb      	strb	r3, [r7, #15]
	for (u8 index = 0;
 80090a2:	2300      	movs	r3, #0
 80090a4:	73bb      	strb	r3, [r7, #14]
 80090a6:	e00f      	b.n	80090c8 <StringCom+0x34>
			ptr_SourceSTring[index] != '#' || ptr_CopySTring[index] != '#';
			index++) {
		if (ptr_SourceSTring[index] == ptr_CopySTring[index]) {
 80090a8:	7bbb      	ldrb	r3, [r7, #14]
 80090aa:	687a      	ldr	r2, [r7, #4]
 80090ac:	4413      	add	r3, r2
 80090ae:	781a      	ldrb	r2, [r3, #0]
 80090b0:	7bbb      	ldrb	r3, [r7, #14]
 80090b2:	6839      	ldr	r1, [r7, #0]
 80090b4:	440b      	add	r3, r1
 80090b6:	781b      	ldrb	r3, [r3, #0]
 80090b8:	429a      	cmp	r2, r3
 80090ba:	d002      	beq.n	80090c2 <StringCom+0x2e>

		} else {
			ReturnValue = FALSE;
 80090bc:	2300      	movs	r3, #0
 80090be:	73fb      	strb	r3, [r7, #15]
			break;
 80090c0:	e00e      	b.n	80090e0 <StringCom+0x4c>
			index++) {
 80090c2:	7bbb      	ldrb	r3, [r7, #14]
 80090c4:	3301      	adds	r3, #1
 80090c6:	73bb      	strb	r3, [r7, #14]
			ptr_SourceSTring[index] != '#' || ptr_CopySTring[index] != '#';
 80090c8:	7bbb      	ldrb	r3, [r7, #14]
 80090ca:	687a      	ldr	r2, [r7, #4]
 80090cc:	4413      	add	r3, r2
 80090ce:	781b      	ldrb	r3, [r3, #0]
 80090d0:	2b23      	cmp	r3, #35	; 0x23
 80090d2:	d1e9      	bne.n	80090a8 <StringCom+0x14>
 80090d4:	7bbb      	ldrb	r3, [r7, #14]
 80090d6:	683a      	ldr	r2, [r7, #0]
 80090d8:	4413      	add	r3, r2
 80090da:	781b      	ldrb	r3, [r3, #0]
 80090dc:	2b23      	cmp	r3, #35	; 0x23
 80090de:	d1e3      	bne.n	80090a8 <StringCom+0x14>
		}
	}
	return ReturnValue;
 80090e0:	7bfb      	ldrb	r3, [r7, #15]
}
 80090e2:	4618      	mov	r0, r3
 80090e4:	3714      	adds	r7, #20
 80090e6:	46bd      	mov	sp, r7
 80090e8:	bc80      	pop	{r7}
 80090ea:	4770      	bx	lr

080090ec <App_HandelFlames>:
		}
	}
	return ReturnValue;
}

void App_HandelFlames(void) {
 80090ec:	b580      	push	{r7, lr}
 80090ee:	b082      	sub	sp, #8
 80090f0:	af00      	add	r7, sp, #0

	if (dataReciev == 1) {
 80090f2:	4b17      	ldr	r3, [pc, #92]	; (8009150 <App_HandelFlames+0x64>)
 80090f4:	781b      	ldrb	r3, [r3, #0]
 80090f6:	b2db      	uxtb	r3, r3
 80090f8:	2b01      	cmp	r3, #1
 80090fa:	d109      	bne.n	8009110 <App_HandelFlames+0x24>
		//UART1_u8SendStringBusyW8(Global_u8ArryReciveDirectUart);
		//UART1_u8SendStringBusyW8("\n");
		if (StringCom(WIFI_FRAMECASE_HAVEUPDATE,
 80090fc:	4915      	ldr	r1, [pc, #84]	; (8009154 <App_HandelFlames+0x68>)
 80090fe:	4816      	ldr	r0, [pc, #88]	; (8009158 <App_HandelFlames+0x6c>)
 8009100:	f7ff ffc8 	bl	8009094 <StringCom>
 8009104:	4603      	mov	r3, r0
 8009106:	2b01      	cmp	r3, #1
 8009108:	d102      	bne.n	8009110 <App_HandelFlames+0x24>
				Global_u8ArryReciveDirectUart) == TRUE) {
			Global_enuAppStates = APP_normal_CHECKPB;
 800910a:	4b14      	ldr	r3, [pc, #80]	; (800915c <App_HandelFlames+0x70>)
 800910c:	2204      	movs	r2, #4
 800910e:	701a      	strb	r2, [r3, #0]
		}  else {

		}
	}
	if (Global_u8StackPointerArryRecive > WIFI_MAXSIZE || dataReciev == 1) {
 8009110:	4b13      	ldr	r3, [pc, #76]	; (8009160 <App_HandelFlames+0x74>)
 8009112:	781b      	ldrb	r3, [r3, #0]
 8009114:	2b32      	cmp	r3, #50	; 0x32
 8009116:	d804      	bhi.n	8009122 <App_HandelFlames+0x36>
 8009118:	4b0d      	ldr	r3, [pc, #52]	; (8009150 <App_HandelFlames+0x64>)
 800911a:	781b      	ldrb	r3, [r3, #0]
 800911c:	b2db      	uxtb	r3, r3
 800911e:	2b01      	cmp	r3, #1
 8009120:	d112      	bne.n	8009148 <App_HandelFlames+0x5c>
		dataReciev = 0;
 8009122:	4b0b      	ldr	r3, [pc, #44]	; (8009150 <App_HandelFlames+0x64>)
 8009124:	2200      	movs	r2, #0
 8009126:	701a      	strb	r2, [r3, #0]
		for (u8 index = 0; index <= WIFI_MAXSIZE; index++) {
 8009128:	2300      	movs	r3, #0
 800912a:	71fb      	strb	r3, [r7, #7]
 800912c:	e006      	b.n	800913c <App_HandelFlames+0x50>
			Global_u8ArryReciveDirectUart[index] = 0;
 800912e:	79fb      	ldrb	r3, [r7, #7]
 8009130:	4a08      	ldr	r2, [pc, #32]	; (8009154 <App_HandelFlames+0x68>)
 8009132:	2100      	movs	r1, #0
 8009134:	54d1      	strb	r1, [r2, r3]
		for (u8 index = 0; index <= WIFI_MAXSIZE; index++) {
 8009136:	79fb      	ldrb	r3, [r7, #7]
 8009138:	3301      	adds	r3, #1
 800913a:	71fb      	strb	r3, [r7, #7]
 800913c:	79fb      	ldrb	r3, [r7, #7]
 800913e:	2b32      	cmp	r3, #50	; 0x32
 8009140:	d9f5      	bls.n	800912e <App_HandelFlames+0x42>
		}
		Global_u8StackPointerArryRecive = 0;
 8009142:	4b07      	ldr	r3, [pc, #28]	; (8009160 <App_HandelFlames+0x74>)
 8009144:	2200      	movs	r2, #0
 8009146:	701a      	strb	r2, [r3, #0]

	}

}
 8009148:	bf00      	nop
 800914a:	3708      	adds	r7, #8
 800914c:	46bd      	mov	sp, r7
 800914e:	bd80      	pop	{r7, pc}
 8009150:	200000e9 	.word	0x200000e9
 8009154:	20000084 	.word	0x20000084
 8009158:	08009338 	.word	0x08009338
 800915c:	20000070 	.word	0x20000070
 8009160:	200000e8 	.word	0x200000e8

08009164 <App_HandelFlames2>:
void App_HandelFlames2(void) {
 8009164:	b580      	push	{r7, lr}
 8009166:	b082      	sub	sp, #8
 8009168:	af00      	add	r7, sp, #0


	if (dataReciev2 == 1) {
 800916a:	4b22      	ldr	r3, [pc, #136]	; (80091f4 <App_HandelFlames2+0x90>)
 800916c:	781b      	ldrb	r3, [r3, #0]
 800916e:	b2db      	uxtb	r3, r3
 8009170:	2b01      	cmp	r3, #1
 8009172:	d11f      	bne.n	80091b4 <App_HandelFlames2+0x50>
		//UART1_u8SendStringBusyW8(Global_u8ArryReciveDirectUart2);
		//UART1_u8SendStringBusyW8("\n");
		if (StringCom(WIFI_REPORT_ERR, Global_u8ArryReciveDirectUart2) == TRUE) {
 8009174:	4920      	ldr	r1, [pc, #128]	; (80091f8 <App_HandelFlames2+0x94>)
 8009176:	4821      	ldr	r0, [pc, #132]	; (80091fc <App_HandelFlames2+0x98>)
 8009178:	f7ff ff8c 	bl	8009094 <StringCom>
 800917c:	4603      	mov	r3, r0
 800917e:	2b01      	cmp	r3, #1
 8009180:	d103      	bne.n	800918a <App_HandelFlames2+0x26>
			//UART2_u8SendStringBusyW8("OK");
			//	UART1_u8SendStringBusyW8(Global_u8ArryReciveDirectUart2);
			//	UART1_u8SendStringBusyW8("\n");
			Global_enuAppStates = APP_REPORT_ERR1;
 8009182:	4b1f      	ldr	r3, [pc, #124]	; (8009200 <App_HandelFlames2+0x9c>)
 8009184:	2202      	movs	r2, #2
 8009186:	701a      	strb	r2, [r3, #0]
 8009188:	e014      	b.n	80091b4 <App_HandelFlames2+0x50>
		} else if (StringCom(WIFI_REPORT_ERR2,
 800918a:	491b      	ldr	r1, [pc, #108]	; (80091f8 <App_HandelFlames2+0x94>)
 800918c:	481d      	ldr	r0, [pc, #116]	; (8009204 <App_HandelFlames2+0xa0>)
 800918e:	f7ff ff81 	bl	8009094 <StringCom>
 8009192:	4603      	mov	r3, r0
 8009194:	2b01      	cmp	r3, #1
 8009196:	d103      	bne.n	80091a0 <App_HandelFlames2+0x3c>
				Global_u8ArryReciveDirectUart2) == TRUE) {
			//	UART2_u8SendStringBusyW8("OK");
			//	UART1_u8SendStringBusyW8(Global_u8ArryReciveDirectUart2);
			//	UART1_u8SendStringBusyW8("\n");
			Global_enuAppStates = APP_REPORT_ERR2;
 8009198:	4b19      	ldr	r3, [pc, #100]	; (8009200 <App_HandelFlames2+0x9c>)
 800919a:	2203      	movs	r2, #3
 800919c:	701a      	strb	r2, [r3, #0]
 800919e:	e009      	b.n	80091b4 <App_HandelFlames2+0x50>
		} else if (StringCom(CAR_REPORT_REQ,
 80091a0:	4915      	ldr	r1, [pc, #84]	; (80091f8 <App_HandelFlames2+0x94>)
 80091a2:	4819      	ldr	r0, [pc, #100]	; (8009208 <App_HandelFlames2+0xa4>)
 80091a4:	f7ff ff76 	bl	8009094 <StringCom>
 80091a8:	4603      	mov	r3, r0
 80091aa:	2b01      	cmp	r3, #1
 80091ac:	d102      	bne.n	80091b4 <App_HandelFlames2+0x50>
				Global_u8ArryReciveDirectUart2) == TRUE) {
			//	UART2_u8SendStringBusyW8("OK");
			//	UART1_u8SendStringBusyW8(Global_u8ArryReciveDirectUart2);
			//	UART1_u8SendStringBusyW8("\n");
			Global_enuAppStates = APP_REPORT_CONF;
 80091ae:	4b14      	ldr	r3, [pc, #80]	; (8009200 <App_HandelFlames2+0x9c>)
 80091b0:	2205      	movs	r2, #5
 80091b2:	701a      	strb	r2, [r3, #0]

			//do noting
		}
	}

	if (Global_u8StackPointerArryRecive2 > WIFI_MAXSIZE || dataReciev2 == 1) {
 80091b4:	4b15      	ldr	r3, [pc, #84]	; (800920c <App_HandelFlames2+0xa8>)
 80091b6:	781b      	ldrb	r3, [r3, #0]
 80091b8:	2b32      	cmp	r3, #50	; 0x32
 80091ba:	d804      	bhi.n	80091c6 <App_HandelFlames2+0x62>
 80091bc:	4b0d      	ldr	r3, [pc, #52]	; (80091f4 <App_HandelFlames2+0x90>)
 80091be:	781b      	ldrb	r3, [r3, #0]
 80091c0:	b2db      	uxtb	r3, r3
 80091c2:	2b01      	cmp	r3, #1
 80091c4:	d112      	bne.n	80091ec <App_HandelFlames2+0x88>
		dataReciev2 = 0;
 80091c6:	4b0b      	ldr	r3, [pc, #44]	; (80091f4 <App_HandelFlames2+0x90>)
 80091c8:	2200      	movs	r2, #0
 80091ca:	701a      	strb	r2, [r3, #0]
		for (u8 index = 0; index <= WIFI_MAXSIZE; index++) {
 80091cc:	2300      	movs	r3, #0
 80091ce:	71fb      	strb	r3, [r7, #7]
 80091d0:	e006      	b.n	80091e0 <App_HandelFlames2+0x7c>
			Global_u8ArryReciveDirectUart2[index] = 0;
 80091d2:	79fb      	ldrb	r3, [r7, #7]
 80091d4:	4a08      	ldr	r2, [pc, #32]	; (80091f8 <App_HandelFlames2+0x94>)
 80091d6:	2100      	movs	r1, #0
 80091d8:	54d1      	strb	r1, [r2, r3]
		for (u8 index = 0; index <= WIFI_MAXSIZE; index++) {
 80091da:	79fb      	ldrb	r3, [r7, #7]
 80091dc:	3301      	adds	r3, #1
 80091de:	71fb      	strb	r3, [r7, #7]
 80091e0:	79fb      	ldrb	r3, [r7, #7]
 80091e2:	2b32      	cmp	r3, #50	; 0x32
 80091e4:	d9f5      	bls.n	80091d2 <App_HandelFlames2+0x6e>
		}
		Global_u8StackPointerArryRecive2 = 0;
 80091e6:	4b09      	ldr	r3, [pc, #36]	; (800920c <App_HandelFlames2+0xa8>)
 80091e8:	2200      	movs	r2, #0
 80091ea:	701a      	strb	r2, [r3, #0]
	}

}
 80091ec:	bf00      	nop
 80091ee:	3708      	adds	r7, #8
 80091f0:	46bd      	mov	sp, r7
 80091f2:	bd80      	pop	{r7, pc}
 80091f4:	20000151 	.word	0x20000151
 80091f8:	200000ec 	.word	0x200000ec
 80091fc:	08009340 	.word	0x08009340
 8009200:	20000070 	.word	0x20000070
 8009204:	08009348 	.word	0x08009348
 8009208:	08009350 	.word	0x08009350
 800920c:	20000150 	.word	0x20000150

08009210 <UartFunction>:

void UartFunction(void) {
 8009210:	b580      	push	{r7, lr}
 8009212:	b082      	sub	sp, #8
 8009214:	af00      	add	r7, sp, #0
	u8 local_u8datalast = 0;
 8009216:	2300      	movs	r3, #0
 8009218:	71fb      	strb	r3, [r7, #7]

	UART1_u8RecieveByte(&local_u8datalast);
 800921a:	1dfb      	adds	r3, r7, #7
 800921c:	4618      	mov	r0, r3
 800921e:	f7ff fe03 	bl	8008e28 <UART1_u8RecieveByte>
	UART2_u8SendByteBusyw8(local_u8datalast);
 8009222:	79fb      	ldrb	r3, [r7, #7]
 8009224:	4618      	mov	r0, r3
 8009226:	f7ff fe95 	bl	8008f54 <UART2_u8SendByteBusyw8>

	Global_u8ArryReciveDirectUart[Global_u8StackPointerArryRecive] =
 800922a:	4b0b      	ldr	r3, [pc, #44]	; (8009258 <UartFunction+0x48>)
 800922c:	781b      	ldrb	r3, [r3, #0]
 800922e:	461a      	mov	r2, r3
 8009230:	79f9      	ldrb	r1, [r7, #7]
 8009232:	4b0a      	ldr	r3, [pc, #40]	; (800925c <UartFunction+0x4c>)
 8009234:	5499      	strb	r1, [r3, r2]
			local_u8datalast;
	Global_u8StackPointerArryRecive++;
 8009236:	4b08      	ldr	r3, [pc, #32]	; (8009258 <UartFunction+0x48>)
 8009238:	781b      	ldrb	r3, [r3, #0]
 800923a:	3301      	adds	r3, #1
 800923c:	b2da      	uxtb	r2, r3
 800923e:	4b06      	ldr	r3, [pc, #24]	; (8009258 <UartFunction+0x48>)
 8009240:	701a      	strb	r2, [r3, #0]
	if (local_u8datalast == '#') {
 8009242:	79fb      	ldrb	r3, [r7, #7]
 8009244:	2b23      	cmp	r3, #35	; 0x23
 8009246:	d102      	bne.n	800924e <UartFunction+0x3e>
		dataReciev = 1;
 8009248:	4b05      	ldr	r3, [pc, #20]	; (8009260 <UartFunction+0x50>)
 800924a:	2201      	movs	r2, #1
 800924c:	701a      	strb	r2, [r3, #0]
	}

}
 800924e:	bf00      	nop
 8009250:	3708      	adds	r7, #8
 8009252:	46bd      	mov	sp, r7
 8009254:	bd80      	pop	{r7, pc}
 8009256:	bf00      	nop
 8009258:	200000e8 	.word	0x200000e8
 800925c:	20000084 	.word	0x20000084
 8009260:	200000e9 	.word	0x200000e9

08009264 <Uart2Function>:
void Uart2Function(void) {
 8009264:	b580      	push	{r7, lr}
 8009266:	b082      	sub	sp, #8
 8009268:	af00      	add	r7, sp, #0
	u8 local_u8datalast = 0;
 800926a:	2300      	movs	r3, #0
 800926c:	71fb      	strb	r3, [r7, #7]

	UART2_u8RecieveByte(&local_u8datalast);
 800926e:	1dfb      	adds	r3, r7, #7
 8009270:	4618      	mov	r0, r3
 8009272:	f7ff fe8f 	bl	8008f94 <UART2_u8RecieveByte>
	//UART1_u8SendByteBusyw8(local_u8datalast);

	Global_u8ArryReciveDirectUart2[Global_u8StackPointerArryRecive2] =
 8009276:	4b0b      	ldr	r3, [pc, #44]	; (80092a4 <Uart2Function+0x40>)
 8009278:	781b      	ldrb	r3, [r3, #0]
 800927a:	461a      	mov	r2, r3
 800927c:	79f9      	ldrb	r1, [r7, #7]
 800927e:	4b0a      	ldr	r3, [pc, #40]	; (80092a8 <Uart2Function+0x44>)
 8009280:	5499      	strb	r1, [r3, r2]
			local_u8datalast;
	Global_u8StackPointerArryRecive2++;
 8009282:	4b08      	ldr	r3, [pc, #32]	; (80092a4 <Uart2Function+0x40>)
 8009284:	781b      	ldrb	r3, [r3, #0]
 8009286:	3301      	adds	r3, #1
 8009288:	b2da      	uxtb	r2, r3
 800928a:	4b06      	ldr	r3, [pc, #24]	; (80092a4 <Uart2Function+0x40>)
 800928c:	701a      	strb	r2, [r3, #0]
	 Global_u8ArryReciveDirectUart2[index] = 0;
	 }
	 Global_u8StackPointerArryRecive2 = 0;
	 }
	 */
	if (local_u8datalast == '#') {
 800928e:	79fb      	ldrb	r3, [r7, #7]
 8009290:	2b23      	cmp	r3, #35	; 0x23
 8009292:	d102      	bne.n	800929a <Uart2Function+0x36>
		dataReciev2 = 1;
 8009294:	4b05      	ldr	r3, [pc, #20]	; (80092ac <Uart2Function+0x48>)
 8009296:	2201      	movs	r2, #1
 8009298:	701a      	strb	r2, [r3, #0]
	}

}
 800929a:	bf00      	nop
 800929c:	3708      	adds	r7, #8
 800929e:	46bd      	mov	sp, r7
 80092a0:	bd80      	pop	{r7, pc}
 80092a2:	bf00      	nop
 80092a4:	20000150 	.word	0x20000150
 80092a8:	200000ec 	.word	0x200000ec
 80092ac:	20000151 	.word	0x20000151

080092b0 <__libc_init_array>:
 80092b0:	b570      	push	{r4, r5, r6, lr}
 80092b2:	2600      	movs	r6, #0
 80092b4:	4d0c      	ldr	r5, [pc, #48]	; (80092e8 <__libc_init_array+0x38>)
 80092b6:	4c0d      	ldr	r4, [pc, #52]	; (80092ec <__libc_init_array+0x3c>)
 80092b8:	1b64      	subs	r4, r4, r5
 80092ba:	10a4      	asrs	r4, r4, #2
 80092bc:	42a6      	cmp	r6, r4
 80092be:	d109      	bne.n	80092d4 <__libc_init_array+0x24>
 80092c0:	f000 f81a 	bl	80092f8 <_init>
 80092c4:	2600      	movs	r6, #0
 80092c6:	4d0a      	ldr	r5, [pc, #40]	; (80092f0 <__libc_init_array+0x40>)
 80092c8:	4c0a      	ldr	r4, [pc, #40]	; (80092f4 <__libc_init_array+0x44>)
 80092ca:	1b64      	subs	r4, r4, r5
 80092cc:	10a4      	asrs	r4, r4, #2
 80092ce:	42a6      	cmp	r6, r4
 80092d0:	d105      	bne.n	80092de <__libc_init_array+0x2e>
 80092d2:	bd70      	pop	{r4, r5, r6, pc}
 80092d4:	f855 3b04 	ldr.w	r3, [r5], #4
 80092d8:	4798      	blx	r3
 80092da:	3601      	adds	r6, #1
 80092dc:	e7ee      	b.n	80092bc <__libc_init_array+0xc>
 80092de:	f855 3b04 	ldr.w	r3, [r5], #4
 80092e2:	4798      	blx	r3
 80092e4:	3601      	adds	r6, #1
 80092e6:	e7f2      	b.n	80092ce <__libc_init_array+0x1e>
 80092e8:	080093b8 	.word	0x080093b8
 80092ec:	080093b8 	.word	0x080093b8
 80092f0:	080093b8 	.word	0x080093b8
 80092f4:	080093bc 	.word	0x080093bc

080092f8 <_init>:
 80092f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80092fa:	bf00      	nop
 80092fc:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80092fe:	bc08      	pop	{r3}
 8009300:	469e      	mov	lr, r3
 8009302:	4770      	bx	lr

08009304 <_fini>:
 8009304:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009306:	bf00      	nop
 8009308:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800930a:	bc08      	pop	{r3}
 800930c:	469e      	mov	lr, r3
 800930e:	4770      	bx	lr
